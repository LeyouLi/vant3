{
  "version": 3,
  "sources": ["../../../../node_modules/@formily/reactive/src/externals.ts", "../../../../node_modules/@formily/reactive/src/checkers.ts", "../../../../node_modules/@formily/reactive/src/environment.ts", "../../../../node_modules/@formily/reactive/src/array.ts", "../../../../node_modules/@formily/reactive/src/tree.ts", "../../../../node_modules/@formily/reactive/src/batch.ts", "../../../../node_modules/@formily/reactive/src/reaction.ts", "../../../../node_modules/@formily/reactive/src/internals.ts", "../../../../node_modules/@formily/reactive/src/handlers.ts", "../../../../node_modules/@formily/reactive/src/autorun.ts", "../../../../node_modules/@formily/reactive/src/tracker.ts", "../../../../node_modules/@formily/reactive/src/index.ts", "../../../../node_modules/@formily/reactive/src/action.ts", "../../../../node_modules/@formily/reactive/src/untracked.ts", "../../../../node_modules/@formily/reactive/src/observable.ts", "../../../../node_modules/@formily/reactive/src/annotations/index.ts", "../../../../node_modules/@formily/reactive/src/annotations/observable.ts", "../../../../node_modules/@formily/reactive/src/annotations/box.ts", "../../../../node_modules/@formily/reactive/src/annotations/ref.ts", "../../../../node_modules/@formily/reactive/src/annotations/shallow.ts", "../../../../node_modules/@formily/reactive/src/annotations/computed.ts", "../../../../node_modules/@formily/reactive/src/model.ts", "../../../../node_modules/@formily/reactive/src/observe.ts", "../../../../node_modules/@formily/reactive/src/types.ts"],
  "sourcesContent": ["import {\n  isValid,\n  isFn,\n  isMap,\n  isWeakMap,\n  isSet,\n  isWeakSet,\n  isPlainObj,\n  isArr,\n} from './checkers'\nimport {\n  ProxyRaw,\n  MakeObservableSymbol,\n  DependencyCollected,\n} from './environment'\nimport { getDataNode } from './tree'\nimport { Annotation } from './types'\n\nconst RAW_TYPE = Symbol('RAW_TYPE')\nconst OBSERVABLE_TYPE = Symbol('OBSERVABLE_TYPE')\nconst hasOwnProperty = Object.prototype.hasOwnProperty\n\nexport const isObservable = (target: any) => {\n  return ProxyRaw.has(target)\n}\n\nexport const isAnnotation = (target: any): target is Annotation => {\n  return target && !!target[MakeObservableSymbol]\n}\n\nexport const isSupportObservable = (target: any) => {\n  if (!isValid(target)) return false\n  if (isArr(target)) return true\n  if (isPlainObj(target)) {\n    if (target[RAW_TYPE]) {\n      return false\n    }\n    if (target[OBSERVABLE_TYPE]) {\n      return true\n    }\n    if ('$$typeof' in target && '_owner' in target) {\n      return false\n    }\n    if (target['_isAMomentObject']) {\n      return false\n    }\n    if (target['_isJSONSchemaObject']) {\n      return false\n    }\n    if (isFn(target['toJS'])) {\n      return false\n    }\n    if (isFn(target['toJSON'])) {\n      return false\n    }\n    return true\n  }\n  if (isMap(target) || isWeakMap(target) || isSet(target) || isWeakSet(target))\n    return true\n  return false\n}\n\nexport const markRaw = <T>(target: T): T => {\n  if (!target) return\n  if (isFn(target)) {\n    target.prototype[RAW_TYPE] = true\n  } else {\n    target[RAW_TYPE] = true\n  }\n  return target\n}\n\nexport const markObservable = <T>(target: T): T => {\n  if (!target) return\n  if (isFn(target)) {\n    target.prototype[OBSERVABLE_TYPE] = true\n  } else {\n    target[OBSERVABLE_TYPE] = true\n  }\n  return target\n}\n\nexport const raw = <T>(target: T): T => ProxyRaw.get(target as any)\n\nexport const toJS = <T>(values: T): T => {\n  const visited = new WeakSet<any>()\n  const _toJS: typeof toJS = (values: any) => {\n    if (visited.has(values)) {\n      return values\n    }\n    if (values && values[RAW_TYPE]) return values\n    if (isArr(values)) {\n      if (isObservable(values)) {\n        visited.add(values)\n        const res: any = []\n        values.forEach((item: any) => {\n          res.push(_toJS(item))\n        })\n        visited.delete(values)\n        return res\n      }\n    } else if (isPlainObj(values)) {\n      if (isObservable(values)) {\n        visited.add(values)\n        const res: any = {}\n        for (const key in values) {\n          if (hasOwnProperty.call(values, key)) {\n            res[key] = _toJS(values[key])\n          }\n        }\n        visited.delete(values)\n        return res\n      }\n    }\n    return values\n  }\n\n  return _toJS(values)\n}\n\nexport const contains = (target: any, property: any) => {\n  const targetRaw = ProxyRaw.get(target) || target\n  const propertyRaw = ProxyRaw.get(property) || property\n  if (targetRaw === propertyRaw) return true\n  const targetNode = getDataNode(targetRaw)\n  const propertyNode = getDataNode(propertyRaw)\n  if (!targetNode) return false\n  if (!propertyNode) return false\n  return targetNode.contains(propertyNode)\n}\n\nexport const hasCollected = (callback?: () => void) => {\n  DependencyCollected.value = false\n  callback?.()\n  return DependencyCollected.value\n}\n", "const toString = Object.prototype.toString\nexport const isMap = (val: any): val is Map<any, any> =>\n  val && val instanceof Map\nexport const isSet = (val: any): val is Set<any> => val && val instanceof Set\nexport const isWeakMap = (val: any): val is WeakMap<any, any> =>\n  val && val instanceof WeakMap\nexport const isWeakSet = (val: any): val is WeakSet<any> =>\n  val && val instanceof WeakSet\nexport const isFn = (val: any): val is Function => typeof val === 'function'\nexport const isArr = Array.isArray\nexport const isPlainObj = (val: any): val is object =>\n  toString.call(val) === '[object Object]'\nexport const isValid = (val: any) => val !== null && val !== undefined\nexport const isCollectionType = (target: any) => {\n  return (\n    isMap(target) || isWeakMap(target) || isSet(target) || isWeakSet(target)\n  )\n}\nexport const isNormalType = (target: any) => {\n  return isPlainObj(target) || isArr(target)\n}\n", "import { ObservableListener, Reaction, ReactionsMap } from './types'\nimport { ArraySet } from './array'\nimport { DataNode } from './tree'\n\nexport const ProxyRaw = new WeakMap()\nexport const RawProxy = new WeakMap()\nexport const RawShallowProxy = new WeakMap()\nexport const RawNode = new WeakMap<object, DataNode>()\nexport const RawReactionsMap = new WeakMap<object, ReactionsMap>()\n\nexport const ReactionStack: Reaction[] = []\nexport const BatchCount = { value: 0 }\nexport const UntrackCount = { value: 0 }\nexport const BatchScope = { value: false }\nexport const DependencyCollected = { value: false }\nexport const PendingReactions = new ArraySet<Reaction>()\nexport const PendingScopeReactions = new ArraySet<Reaction>()\nexport const BatchEndpoints = new ArraySet<() => void>()\nexport const MakeObservableSymbol = Symbol('MakeObservableSymbol')\nexport const ObserverListeners = new ArraySet<ObservableListener>()\n", "export const toArray = (value: any) => {\n  return Array.isArray(value)\n    ? value\n    : value !== undefined && value !== null\n    ? [value]\n    : []\n}\n\nexport class ArraySet<T> {\n  value: T[]\n  batchDeleting = false\n  constructor(value: T[] = []) {\n    this.value = value\n  }\n\n  add(item: T) {\n    if (!this.has(item)) {\n      this.value.push(item)\n    }\n  }\n\n  has(item: T) {\n    return this.value.indexOf(item) > -1\n  }\n\n  delete(item: T) {\n    if (this.batchDeleting) return //\u6279\u91CF\u5220\u9664\u65F6\u7981\u6B62\u5355\u72EC\u5220\u9664\uFF0C\u4F1A\u5F71\u54CD\u8BA1\u6570\u6267\u884C\u5668\n    const index = this.value.indexOf(item)\n    if (index > -1) {\n      this.value.splice(index, 1)\n    }\n  }\n\n  forEach(callback: (value: T) => void) {\n    if (this.value.length === 0) return\n    for (let index = 0, len = this.value.length; index < len; index++) {\n      callback(this.value[index])\n    }\n  }\n\n  forEachDelete(callback: (value: T) => void) {\n    if (this.value.length === 0) return\n    this.batchDeleting = true\n    for (let index = 0; index < this.value.length; index++) {\n      const item = this.value[index]\n      this.value.splice(index, 1)\n      callback(item)\n      index--\n    }\n    this.batchDeleting = false\n  }\n\n  clear() {\n    this.value.length = 0\n  }\n}\n", "import { RawNode, ProxyRaw } from './environment'\nimport { ObservablePath, PropertyKey, IOperation } from './types'\nexport class DataChange {\n  path: ObservablePath\n  key: PropertyKey\n  object: object\n  type: string\n  value: any\n  oldValue: any\n  constructor(operation: IOperation, node: DataNode) {\n    this.key = operation.key\n    this.type = operation.type\n    this.object = operation.target\n    this.value = operation.value\n    this.oldValue = operation.oldValue\n    this.path = node.path.concat(operation.key)\n  }\n}\nexport class DataNode {\n  target: any\n\n  key: PropertyKey\n\n  value: any\n\n  constructor(target: any, key: PropertyKey, value: any) {\n    this.target = target\n    this.key = key\n    this.value = value\n  }\n\n  get path() {\n    if (!this.parent) return this.key ? [this.key] : []\n    return this.parent.path.concat(this.key)\n  }\n\n  get targetRaw() {\n    return ProxyRaw.get(this.target) || this.target\n  }\n\n  get parent() {\n    if (!this.target) return\n    return getDataNode(this.targetRaw)\n  }\n\n  isEqual(node: DataNode) {\n    if (this.key) {\n      return node.targetRaw === this.targetRaw && node.key === this.key\n    }\n    return node.value === this.value\n  }\n\n  contains(node: DataNode) {\n    if (node === this) return true\n    let parent = node.parent\n    while (!!parent) {\n      if (this.isEqual(parent)) return true\n      parent = parent.parent\n    }\n    return false\n  }\n}\n\nexport const getDataNode = (raw: any) => {\n  return RawNode.get(raw)\n}\n\nexport const setDataNode = (raw: any, node: DataNode) => {\n  RawNode.set(raw, node)\n}\n\nexport const buildDataTree = (target: any, key: PropertyKey, value: any) => {\n  const raw = ProxyRaw.get(value) || value\n  const currentNode = getDataNode(raw)\n  if (currentNode) return currentNode\n  setDataNode(raw, new DataNode(target, key, value))\n}\n", "import {\n  batchStart,\n  batchEnd,\n  batchScopeStart,\n  batchScopeEnd,\n} from './reaction'\nimport { BatchEndpoints, BatchCount } from './environment'\nimport { createBoundaryAnnotation } from './internals'\nimport { IBatch } from './types'\nimport { isFn } from './checkers'\n\nexport const batch: IBatch = createBoundaryAnnotation(batchStart, batchEnd)\nbatch.scope = createBoundaryAnnotation(batchScopeStart, batchScopeEnd)\nbatch.endpoint = (callback?: () => void) => {\n  if (!isFn(callback)) return\n  if (BatchCount.value === 0) {\n    callback()\n  } else {\n    BatchEndpoints.add(callback)\n  }\n}\n", "import { isFn } from './checkers'\nimport { ArraySet } from './array'\nimport { IOperation, ReactionsMap, Reaction, PropertyKey } from './types'\nimport {\n  ReactionStack,\n  PendingScopeReactions,\n  BatchEndpoints,\n  DependencyCollected,\n  RawReactionsMap,\n  PendingReactions,\n  BatchCount,\n  UntrackCount,\n  BatchScope,\n  ObserverListeners,\n} from './environment'\n\nconst ITERATION_KEY = Symbol('iteration key')\n\nconst addRawReactionsMap = (\n  target: any,\n  key: PropertyKey,\n  reaction: Reaction\n) => {\n  const reactionsMap = RawReactionsMap.get(target)\n  if (reactionsMap) {\n    const reactions = reactionsMap.get(key)\n    if (reactions) {\n      reactions.add(reaction)\n    } else {\n      reactionsMap.set(key, new ArraySet([reaction]))\n    }\n    return reactionsMap\n  } else {\n    const reactionsMap: ReactionsMap = new Map([\n      [key, new ArraySet([reaction])],\n    ])\n    RawReactionsMap.set(target, reactionsMap)\n    return reactionsMap\n  }\n}\n\nconst addReactionsMapToReaction = (\n  reaction: Reaction,\n  reactionsMap: ReactionsMap\n) => {\n  const bindSet = reaction._reactionsSet\n  if (bindSet) {\n    bindSet.add(reactionsMap)\n  } else {\n    reaction._reactionsSet = new ArraySet([reactionsMap])\n  }\n  return bindSet\n}\n\nconst getReactionsFromTargetKey = (target: any, key: PropertyKey) => {\n  const reactionsMap = RawReactionsMap.get(target)\n  const reactions = []\n  if (reactionsMap) {\n    const map = reactionsMap.get(key)\n    if (map) {\n      map.forEach((reaction) => {\n        if (reactions.indexOf(reaction) === -1) {\n          reactions.push(reaction)\n        }\n      })\n    }\n  }\n  return reactions\n}\n\nconst runReactions = (target: any, key: PropertyKey) => {\n  const reactions = getReactionsFromTargetKey(target, key)\n  const prevUntrackCount = UntrackCount.value\n  UntrackCount.value = 0\n  for (let i = 0, len = reactions.length; i < len; i++) {\n    const reaction = reactions[i]\n    if (reaction._isComputed) {\n      reaction._scheduler(reaction)\n    } else if (isScopeBatching()) {\n      PendingScopeReactions.add(reaction)\n    } else if (isBatching()) {\n      PendingReactions.add(reaction)\n    } else {\n      if (isFn(reaction._scheduler)) {\n        reaction._scheduler(reaction)\n      } else {\n        reaction()\n      }\n    }\n  }\n  UntrackCount.value = prevUntrackCount\n}\n\nconst notifyObservers = (operation: IOperation) => {\n  ObserverListeners.forEach((fn) => fn(operation))\n}\n\nexport const bindTargetKeyWithCurrentReaction = (operation: IOperation) => {\n  let { key, type, target } = operation\n  if (type === 'iterate') {\n    key = ITERATION_KEY\n  }\n\n  const current = ReactionStack[ReactionStack.length - 1]\n  if (isUntracking()) return\n  if (current) {\n    DependencyCollected.value = true\n    addReactionsMapToReaction(current, addRawReactionsMap(target, key, current))\n  }\n}\n\nexport const bindComputedReactions = (reaction: Reaction) => {\n  if (isFn(reaction)) {\n    const current = ReactionStack[ReactionStack.length - 1]\n    if (current) {\n      const computes = current._computesSet\n      if (computes) {\n        computes.add(reaction)\n      } else {\n        current._computesSet = new ArraySet([reaction])\n      }\n    }\n  }\n}\n\nexport const runReactionsFromTargetKey = (operation: IOperation) => {\n  let { key, type, target, oldTarget } = operation\n  batchStart()\n  notifyObservers(operation)\n  if (type === 'clear') {\n    oldTarget.forEach((_: any, key: PropertyKey) => {\n      runReactions(target, key)\n    })\n  } else {\n    runReactions(target, key)\n  }\n  if (type === 'add' || type === 'delete' || type === 'clear') {\n    const newKey = Array.isArray(target) ? 'length' : ITERATION_KEY\n    runReactions(target, newKey)\n  }\n  batchEnd()\n}\n\nexport const hasRunningReaction = () => {\n  return ReactionStack.length > 0\n}\n\nexport const releaseBindingReactions = (reaction: Reaction) => {\n  reaction._reactionsSet?.forEach((reactionsMap) => {\n    reactionsMap.forEach((reactions) => {\n      reactions.delete(reaction)\n    })\n  })\n  PendingReactions.delete(reaction)\n  PendingScopeReactions.delete(reaction)\n  delete reaction._reactionsSet\n}\n\nexport const suspendComputedReactions = (current: Reaction) => {\n  current._computesSet?.forEach((reaction) => {\n    const reactions = getReactionsFromTargetKey(\n      reaction._context,\n      reaction._property\n    )\n    if (reactions.length === 0) {\n      disposeBindingReactions(reaction)\n      reaction._dirty = true\n    }\n  })\n}\n\nexport const disposeBindingReactions = (reaction: Reaction) => {\n  reaction._disposed = true\n  releaseBindingReactions(reaction)\n  suspendComputedReactions(reaction)\n}\n\nexport const batchStart = () => {\n  BatchCount.value++\n}\n\nexport const batchEnd = () => {\n  BatchCount.value--\n  if (BatchCount.value === 0) {\n    const prevUntrackCount = UntrackCount.value\n    UntrackCount.value = 0\n    executePendingReactions()\n    executeBatchEndpoints()\n    UntrackCount.value = prevUntrackCount\n  }\n}\n\nexport const batchScopeStart = () => {\n  BatchScope.value = true\n}\n\nexport const batchScopeEnd = () => {\n  const prevUntrackCount = UntrackCount.value\n  BatchScope.value = false\n  UntrackCount.value = 0\n  PendingScopeReactions.forEachDelete((reaction) => {\n    if (isFn(reaction._scheduler)) {\n      reaction._scheduler(reaction)\n    } else {\n      reaction()\n    }\n  })\n  UntrackCount.value = prevUntrackCount\n}\n\nexport const untrackStart = () => {\n  UntrackCount.value++\n}\n\nexport const untrackEnd = () => {\n  UntrackCount.value--\n}\n\nexport const isBatching = () => BatchCount.value > 0\n\nexport const isScopeBatching = () => BatchScope.value\n\nexport const isUntracking = () => UntrackCount.value > 0\n\nexport const executePendingReactions = () => {\n  PendingReactions.forEachDelete((reaction) => {\n    if (isFn(reaction._scheduler)) {\n      reaction._scheduler(reaction)\n    } else {\n      reaction()\n    }\n  })\n}\n\nexport const executeBatchEndpoints = () => {\n  BatchEndpoints.forEachDelete((callback) => {\n    callback()\n  })\n}\n\nexport const hasDepsChange = (newDeps: any[], oldDeps: any[]) => {\n  if (newDeps === oldDeps) return false\n  if (newDeps.length !== oldDeps.length) return true\n  if (newDeps.some((value, index) => value !== oldDeps[index])) return true\n  return false\n}\n\nexport const disposeEffects = (reaction: Reaction) => {\n  if (reaction._effects) {\n    try {\n      batchStart()\n      reaction._effects.queue.forEach((item) => {\n        if (!item || !item.dispose) return\n        item.dispose()\n      })\n    } finally {\n      batchEnd()\n    }\n  }\n}\n", "import { isFn, isCollectionType, isNormalType } from './checkers'\nimport {\n  RawProxy,\n  ProxyRaw,\n  MakeObservableSymbol,\n  RawShallowProxy,\n} from './environment'\nimport { baseHandlers, collectionHandlers } from './handlers'\nimport { buildDataTree, getDataNode } from './tree'\nimport { isSupportObservable } from './externals'\nimport { PropertyKey, IVisitor, BoundaryFunction } from './types'\n\nconst createNormalProxy = (target: any, shallow?: boolean) => {\n  const proxy = new Proxy(target, baseHandlers)\n  ProxyRaw.set(proxy, target)\n  if (shallow) {\n    RawShallowProxy.set(target, proxy)\n  } else {\n    RawProxy.set(target, proxy)\n  }\n  return proxy\n}\n\nconst createCollectionProxy = (target: any, shallow?: boolean) => {\n  const proxy = new Proxy(target, collectionHandlers)\n  ProxyRaw.set(proxy, target)\n  if (shallow) {\n    RawShallowProxy.set(target, proxy)\n  } else {\n    RawProxy.set(target, proxy)\n  }\n  return proxy\n}\n\nconst createShallowProxy = (target: any) => {\n  if (isNormalType(target)) return createNormalProxy(target, true)\n  if (isCollectionType(target)) return createCollectionProxy(target, true)\n  return target\n}\n\nexport const createObservable = (\n  target: any,\n  key?: PropertyKey,\n  value?: any,\n  shallow?: boolean\n) => {\n  if (typeof value !== 'object') return value\n  const raw = ProxyRaw.get(value)\n  if (!!raw) {\n    const node = getDataNode(raw)\n    if (!node.target) node.target = target\n    node.key = key\n    return value\n  }\n\n  if (!isSupportObservable(value)) return value\n\n  if (target) {\n    const parentRaw = ProxyRaw.get(target) || target\n    const isShallowParent = RawShallowProxy.get(parentRaw)\n    if (isShallowParent) return value\n  }\n\n  buildDataTree(target, key, value)\n  if (shallow) return createShallowProxy(value)\n  if (isNormalType(value)) return createNormalProxy(value)\n  if (isCollectionType(value)) return createCollectionProxy(value)\n  return value\n}\n\nexport const createAnnotation = <T extends (visitor: IVisitor) => any>(\n  maker: T\n) => {\n  const annotation = (target: any): ReturnType<T> => {\n    return maker({ value: target })\n  }\n  if (isFn(maker)) {\n    annotation[MakeObservableSymbol] = maker\n  }\n  return annotation\n}\n\nexport const getObservableMaker = (target: any) => {\n  if (target[MakeObservableSymbol]) {\n    if (!target[MakeObservableSymbol][MakeObservableSymbol]) {\n      return target[MakeObservableSymbol]\n    }\n    return getObservableMaker(target[MakeObservableSymbol])\n  }\n}\n\nexport const createBoundaryFunction = (\n  start: (...args: any) => void,\n  end: (...args: any) => void\n) => {\n  function boundary<F extends (...args: any) => any>(fn?: F): ReturnType<F> {\n    let results: ReturnType<F>\n    try {\n      start()\n      if (isFn(fn)) {\n        results = fn()\n      }\n    } finally {\n      end()\n    }\n    return results\n  }\n\n  boundary.bound = createBindFunction(boundary)\n  return boundary\n}\n\nexport const createBindFunction = <Boundary extends BoundaryFunction>(\n  boundary: Boundary\n) => {\n  function bind<F extends (...args: any[]) => any>(\n    callback?: F,\n    context?: any\n  ): F {\n    return ((...args: any[]) =>\n      boundary(() => callback.apply(context, args))) as any\n  }\n  return bind\n}\n\nexport const createBoundaryAnnotation = (\n  start: (...args: any) => void,\n  end: (...args: any) => void\n) => {\n  const boundary = createBoundaryFunction(start, end)\n  const annotation = createAnnotation(({ target, key }) => {\n    target[key] = boundary.bound(target[key], target)\n    return target\n  })\n  boundary[MakeObservableSymbol] = annotation\n  boundary.bound[MakeObservableSymbol] = annotation\n  return boundary\n}\n", "import {\n  bindTargetKeyWithCurrentReaction,\n  runReactionsFromTargetKey,\n} from './reaction'\nimport { ProxyRaw, RawProxy } from './environment'\nimport { isObservable, isSupportObservable } from './externals'\nimport { createObservable } from './internals'\n\nconst wellKnownSymbols = new Set(\n  Object.getOwnPropertyNames(Symbol)\n    .map((key) => Symbol[key])\n    .filter((value) => typeof value === 'symbol')\n)\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty\n\nfunction findObservable(target: any, key: PropertyKey, value: any) {\n  const observableObj = RawProxy.get(value)\n  if (observableObj) {\n    return observableObj\n  }\n  if (!isObservable(value) && isSupportObservable(value)) {\n    return createObservable(target, key, value)\n  }\n  return value\n}\n\nfunction patchIterator(\n  target: any,\n  key: PropertyKey,\n  iterator: IterableIterator<any>,\n  isEntries: boolean\n) {\n  const originalNext = iterator.next\n  iterator.next = () => {\n    let { done, value } = originalNext.call(iterator)\n    if (!done) {\n      if (isEntries) {\n        value[1] = findObservable(target, key, value[1])\n      } else {\n        value = findObservable(target, key, value)\n      }\n    }\n    return { done, value }\n  }\n  return iterator\n}\n\nconst instrumentations = {\n  has(key: PropertyKey) {\n    const target = ProxyRaw.get(this)\n    const proto = Reflect.getPrototypeOf(this) as any\n    bindTargetKeyWithCurrentReaction({ target, key, type: 'has' })\n    return proto.has.apply(target, arguments)\n  },\n  get(key: PropertyKey) {\n    const target = ProxyRaw.get(this)\n    const proto = Reflect.getPrototypeOf(this) as any\n    bindTargetKeyWithCurrentReaction({ target, key, type: 'get' })\n    return findObservable(target, key, proto.get.apply(target, arguments))\n  },\n  add(key: PropertyKey) {\n    const target = ProxyRaw.get(this)\n    const proto = Reflect.getPrototypeOf(this) as any\n    const hadKey = proto.has.call(target, key)\n    // forward the operation before queueing reactions\n    const result = proto.add.apply(target, arguments)\n    if (!hadKey) {\n      runReactionsFromTargetKey({ target, key, value: key, type: 'add' })\n    }\n    return result\n  },\n  set(key: PropertyKey, value: any) {\n    const target = ProxyRaw.get(this)\n    const proto = Reflect.getPrototypeOf(this) as any\n    const hadKey = proto.has.call(target, key)\n    const oldValue = proto.get.call(target, key)\n    // forward the operation before queueing reactions\n    const result = proto.set.apply(target, arguments)\n    if (!hadKey) {\n      runReactionsFromTargetKey({ target, key, value, type: 'add' })\n    } else if (value !== oldValue) {\n      runReactionsFromTargetKey({ target, key, value, oldValue, type: 'set' })\n    }\n    return result\n  },\n  delete(key: PropertyKey) {\n    const target = ProxyRaw.get(this)\n    const proto = Reflect.getPrototypeOf(this) as any\n    const hadKey = proto.has.call(target, key)\n    const oldValue = proto.get ? proto.get.call(target, key) : undefined\n    // forward the operation before queueing reactions\n    const result = proto.delete.apply(target, arguments)\n    if (hadKey) {\n      runReactionsFromTargetKey({ target, key, oldValue, type: 'delete' })\n    }\n    return result\n  },\n  clear() {\n    const target = ProxyRaw.get(this)\n    const proto = Reflect.getPrototypeOf(this) as any\n    const hadItems = target.size !== 0\n    const oldTarget = target instanceof Map ? new Map(target) : new Set(target)\n    // forward the operation before queueing reactions\n    const result = proto.clear.apply(target, arguments)\n    if (hadItems) {\n      runReactionsFromTargetKey({ target, oldTarget, type: 'clear' })\n    }\n    return result\n  },\n  forEach(cb: any, ...args: any[]) {\n    const target = ProxyRaw.get(this)\n    const proto = Reflect.getPrototypeOf(this) as any\n    bindTargetKeyWithCurrentReaction({ target, type: 'iterate' })\n    // swap out the raw values with their observable pairs\n    // before passing them to the callback\n    const wrappedCb = (value: any, key: PropertyKey, ...args: any) =>\n      cb(findObservable(target, key, value), key, ...args)\n    return proto.forEach.call(target, wrappedCb, ...args)\n  },\n  keys() {\n    const target = ProxyRaw.get(this)\n    const proto = Reflect.getPrototypeOf(this) as any\n    bindTargetKeyWithCurrentReaction({ target, type: 'iterate' })\n    return proto.keys.apply(target, arguments)\n  },\n  values() {\n    const target = ProxyRaw.get(this)\n    const proto = Reflect.getPrototypeOf(this) as any\n    bindTargetKeyWithCurrentReaction({ target, type: 'iterate' })\n    const iterator = proto.values.apply(target, arguments)\n    return patchIterator(target, '', iterator, false)\n  },\n  entries() {\n    const target = ProxyRaw.get(this)\n    const proto = Reflect.getPrototypeOf(this) as any\n    bindTargetKeyWithCurrentReaction({ target, type: 'iterate' })\n    const iterator = proto.entries.apply(target, arguments)\n    return patchIterator(target, '', iterator, true)\n  },\n  [Symbol.iterator]() {\n    const target = ProxyRaw.get(this)\n    const proto = Reflect.getPrototypeOf(this)\n    bindTargetKeyWithCurrentReaction({ target, type: 'iterate' })\n    const iterator = proto[Symbol.iterator].apply(target, arguments)\n    return patchIterator(target, '', iterator, target instanceof Map)\n  },\n  get size() {\n    const target = ProxyRaw.get(this)\n    const proto = Reflect.getPrototypeOf(this)\n    bindTargetKeyWithCurrentReaction({ target, type: 'iterate' })\n    return Reflect.get(proto, 'size', target)\n  },\n}\n\nexport const collectionHandlers = {\n  get(target: any, key: PropertyKey, receiver: any) {\n    // instrument methods and property accessors to be reactive\n    target = hasOwnProperty.call(instrumentations, key)\n      ? instrumentations\n      : target\n    return Reflect.get(target, key, receiver)\n  },\n}\n\nexport const baseHandlers: ProxyHandler<any> = {\n  get(target, key, receiver) {\n    if (!key) return\n    const result = target[key] // use Reflect.get is too slow\n    if (typeof key === 'symbol' && wellKnownSymbols.has(key)) {\n      return result\n    }\n    bindTargetKeyWithCurrentReaction({ target, key, receiver, type: 'get' })\n    const observableResult = RawProxy.get(result)\n    if (observableResult) {\n      return observableResult\n    }\n    if (!isObservable(result) && isSupportObservable(result)) {\n      const descriptor = Reflect.getOwnPropertyDescriptor(target, key)\n      if (\n        !descriptor ||\n        !(descriptor.writable === false && descriptor.configurable === false)\n      ) {\n        return createObservable(target, key, result)\n      }\n    }\n    return result\n  },\n  has(target, key) {\n    const result = Reflect.has(target, key)\n    bindTargetKeyWithCurrentReaction({ target, key, type: 'has' })\n    return result\n  },\n  ownKeys(target) {\n    const keys = Reflect.ownKeys(target)\n    bindTargetKeyWithCurrentReaction({ target, type: 'iterate' })\n    return keys\n  },\n  set(target, key, value, receiver) {\n    const hadKey = hasOwnProperty.call(target, key)\n    const newValue = createObservable(target, key, value)\n    const oldValue = target[key]\n    target[key] = newValue // use Reflect.set is too slow\n    if (!hadKey) {\n      runReactionsFromTargetKey({\n        target,\n        key,\n        value: newValue,\n        oldValue,\n        receiver,\n        type: 'add',\n      })\n    } else if (value !== oldValue) {\n      runReactionsFromTargetKey({\n        target,\n        key,\n        value: newValue,\n        oldValue,\n        receiver,\n        type: 'set',\n      })\n    }\n    return true\n  },\n  deleteProperty(target, key) {\n    const oldValue = target[key]\n    delete target[key]\n    runReactionsFromTargetKey({\n      target,\n      key,\n      oldValue,\n      type: 'delete',\n    })\n    return true\n  },\n}\n", "import {\n  batchEnd,\n  batchStart,\n  disposeBindingReactions,\n  releaseBindingReactions,\n  disposeEffects,\n  hasDepsChange,\n} from './reaction'\nimport { isFn } from './checkers'\nimport { ReactionStack } from './environment'\nimport { Reaction, IReactionOptions, Dispose } from './types'\nimport { toArray } from './array'\n\ninterface IValue {\n  currentValue?: any\n  oldValue?: any\n}\n\nexport const autorun = (tracker: Reaction, name = 'AutoRun') => {\n  const reaction: Reaction = () => {\n    if (!isFn(tracker)) return\n    if (reaction._boundary > 0) return\n    if (ReactionStack.indexOf(reaction) === -1) {\n      releaseBindingReactions(reaction)\n      try {\n        batchStart()\n        ReactionStack.push(reaction)\n        tracker()\n      } finally {\n        ReactionStack.pop()\n        reaction._boundary++\n        batchEnd()\n        reaction._boundary = 0\n        reaction._memos.cursor = 0\n        reaction._effects.cursor = 0\n      }\n    }\n  }\n  const cleanRefs = () => {\n    reaction._memos = {\n      queue: [],\n      cursor: 0,\n    }\n    reaction._effects = {\n      queue: [],\n      cursor: 0,\n    }\n  }\n  reaction._boundary = 0\n  reaction._name = name\n  cleanRefs()\n  reaction()\n  return () => {\n    disposeBindingReactions(reaction)\n    disposeEffects(reaction)\n    cleanRefs()\n  }\n}\n\nautorun.memo = <T>(callback: () => T, dependencies?: any[]): T => {\n  if (!isFn(callback)) return\n  const current = ReactionStack[ReactionStack.length - 1]\n  if (!current || !current._memos)\n    throw new Error('autorun.memo must used in autorun function body.')\n  const deps = toArray(dependencies || [])\n  const id = current._memos.cursor++\n  const old = current._memos.queue[id]\n  if (!old || hasDepsChange(deps, old.deps)) {\n    const value = callback()\n    current._memos.queue[id] = {\n      value,\n      deps,\n    }\n    return value\n  }\n  return old.value\n}\n\nautorun.effect = (callback: () => void | Dispose, dependencies?: any[]) => {\n  if (!isFn(callback)) return\n  const current = ReactionStack[ReactionStack.length - 1]\n  if (!current || !current._effects)\n    throw new Error('autorun.effect must used in autorun function body.')\n  const effects = current._effects\n  const deps = toArray(dependencies || [{}])\n  const id = effects.cursor++\n  const old = effects.queue[id]\n  if (!old || hasDepsChange(deps, old.deps)) {\n    Promise.resolve(0).then(() => {\n      if (current._disposed) return\n      const dispose = callback()\n      if (isFn(dispose)) {\n        effects.queue[id].dispose = dispose\n      }\n    })\n    effects.queue[id] = {\n      deps,\n    }\n  }\n}\n\nexport const reaction = <T>(\n  tracker: () => T,\n  subscriber?: (value: T, oldValue: T) => void,\n  options?: IReactionOptions<T>\n) => {\n  const realOptions = {\n    name: 'Reaction',\n    ...options,\n  }\n  const value: IValue = {}\n  const dirtyCheck = () => {\n    if (isFn(realOptions.equals))\n      return !realOptions.equals(value.oldValue, value.currentValue)\n    return value.oldValue !== value.currentValue\n  }\n\n  const fireAction = () => {\n    try {\n      //\u5982\u679Cuntrack\u7684\u8BDD\uFF0C\u4F1A\u5BFC\u81F4\u7528\u6237\u5982\u679C\u5728scheduler\u91CC\u540C\u6B65\u8C03\u7528setState\u5F71\u54CD\u4E0B\u6B21React\u6E32\u67D3\u7684\u4F9D\u8D56\u6536\u96C6\n      batchStart()\n      if (isFn(subscriber)) subscriber(value.currentValue, value.oldValue)\n    } finally {\n      batchEnd()\n    }\n  }\n\n  const reaction: Reaction = () => {\n    if (ReactionStack.indexOf(reaction) === -1) {\n      releaseBindingReactions(reaction)\n      try {\n        ReactionStack.push(reaction)\n        value.currentValue = tracker()\n      } finally {\n        ReactionStack.pop()\n      }\n    }\n  }\n  reaction._scheduler = (looping) => {\n    looping()\n    if (dirtyCheck()) fireAction()\n    value.oldValue = value.currentValue\n  }\n  reaction._name = realOptions.name\n  reaction()\n  value.oldValue = value.currentValue\n  if (realOptions.fireImmediately) {\n    fireAction()\n  }\n  return () => {\n    disposeBindingReactions(reaction)\n  }\n}\n", "import { ReactionStack } from './environment'\nimport { isFn } from './checkers'\nimport { Reaction } from './types'\nimport {\n  batchEnd,\n  batchStart,\n  disposeBindingReactions,\n  releaseBindingReactions,\n} from './reaction'\n\nexport class Tracker {\n  private results: any\n  constructor(\n    scheduler?: (reaction: Reaction) => void,\n    name = 'TrackerReaction'\n  ) {\n    this.track._scheduler = (callback) => {\n      if (this.track._boundary === 0) this.dispose()\n      if (isFn(callback)) scheduler(callback)\n    }\n    this.track._name = name\n    this.track._boundary = 0\n  }\n\n  track: Reaction = (tracker: Reaction) => {\n    if (!isFn(tracker)) return this.results\n    if (this.track._boundary > 0) return\n    if (ReactionStack.indexOf(this.track) === -1) {\n      releaseBindingReactions(this.track)\n      try {\n        batchStart()\n        ReactionStack.push(this.track)\n        this.results = tracker()\n      } finally {\n        ReactionStack.pop()\n        this.track._boundary++\n        batchEnd()\n        this.track._boundary = 0\n      }\n    }\n    return this.results\n  }\n\n  dispose = () => {\n    disposeBindingReactions(this.track)\n  }\n}\n", "export * from './batch'\nexport * from './action'\nexport * from './untracked'\nexport * from './observable'\nexport * from './model'\nexport * from './autorun'\nexport * from './tracker'\nexport * from './observe'\nexport * from './externals'\nexport * from './types'\n", "import {\n  batchStart,\n  batchEnd,\n  batchScopeStart,\n  batchScopeEnd,\n  untrackStart,\n  untrackEnd,\n} from './reaction'\nimport { createBoundaryAnnotation } from './internals'\nimport { IAction } from './types'\n\nexport const action: IAction = createBoundaryAnnotation(\n  () => {\n    batchStart()\n    untrackStart()\n  },\n  () => {\n    untrackEnd()\n    batchEnd()\n  }\n)\n\naction.scope = createBoundaryAnnotation(\n  () => {\n    batchScopeStart()\n    untrackStart()\n  },\n  () => {\n    untrackEnd()\n    batchScopeEnd()\n  }\n)\n", "import { createBoundaryFunction } from './internals'\nimport { untrackStart, untrackEnd } from './reaction'\n\nexport const untracked = createBoundaryFunction(untrackStart, untrackEnd)\n", "import * as annotations from './annotations'\nimport { MakeObservableSymbol } from './environment'\nimport { createObservable } from './internals'\n\nexport function observable<T extends object>(target: T): T {\n  return createObservable(null, null, target)\n}\n\nobservable.box = annotations.box\nobservable.ref = annotations.ref\nobservable.deep = annotations.observable\nobservable.shallow = annotations.shallow\nobservable.computed = annotations.computed\nobservable[MakeObservableSymbol] = annotations.observable\n", "export * from './observable'\nexport * from './box'\nexport * from './ref'\nexport * from './shallow'\nexport * from './computed'\n", "import { createAnnotation, createObservable } from '../internals'\nimport {\n  bindTargetKeyWithCurrentReaction,\n  runReactionsFromTargetKey,\n} from '../reaction'\n\nexport interface IObservable {\n  <T>(target: T): T\n}\n\nexport const observable: IObservable = createAnnotation(\n  ({ target, key, value }) => {\n    const store = {\n      value: createObservable(target, key, target ? target[key] : value),\n    }\n\n    function get() {\n      bindTargetKeyWithCurrentReaction({\n        target: target,\n        key: key,\n        type: 'get',\n      })\n      return store.value\n    }\n\n    function set(value: any) {\n      const oldValue = store.value\n      value = createObservable(target, key, value)\n      store.value = value\n      if (oldValue === value) return\n      runReactionsFromTargetKey({\n        target: target,\n        key: key,\n        type: 'set',\n        oldValue,\n        value,\n      })\n    }\n    if (target) {\n      Object.defineProperty(target, key, {\n        set,\n        get,\n        enumerable: true,\n        configurable: false,\n      })\n      return target\n    }\n    return store.value\n  }\n)\n", "import { ProxyRaw, RawProxy } from '../environment'\nimport { createAnnotation } from '../internals'\nimport { buildDataTree } from '../tree'\nimport {\n  bindTargetKeyWithCurrentReaction,\n  runReactionsFromTargetKey,\n} from '../reaction'\n\nexport interface IBox {\n  <T>(target: T): { get(): T; set(value: T): void }\n}\n\nexport const box: IBox = createAnnotation(({ target, key, value }) => {\n  const store = {\n    value: target ? target[key] : value,\n  }\n\n  const proxy = {\n    set,\n    get,\n  }\n\n  ProxyRaw.set(proxy, store)\n  RawProxy.set(store, proxy)\n\n  buildDataTree(target, key, store)\n\n  function get() {\n    bindTargetKeyWithCurrentReaction({\n      target: store,\n      key,\n      type: 'get',\n    })\n    return store.value\n  }\n\n  function set(value: any) {\n    const oldValue = store.value\n    store.value = value\n    if (oldValue !== value) {\n      runReactionsFromTargetKey({\n        target: store,\n        key,\n        type: 'set',\n        oldValue,\n        value,\n      })\n    }\n  }\n\n  if (target) {\n    Object.defineProperty(target, key, {\n      value: proxy,\n      enumerable: true,\n      configurable: false,\n      writable: false,\n    })\n    return target\n  }\n  return proxy\n})\n", "import { ProxyRaw, RawProxy } from '../environment'\nimport { createAnnotation } from '../internals'\nimport { buildDataTree } from '../tree'\nimport {\n  bindTargetKeyWithCurrentReaction,\n  runReactionsFromTargetKey,\n} from '../reaction'\n\nexport interface IRef {\n  <T>(target: T): { value: T }\n}\n\nexport const ref: IRef = createAnnotation(({ target, key, value }) => {\n  const store = {\n    value: target ? target[key] : value,\n  }\n\n  const proxy = {}\n\n  const context = target ? target : store\n  const property = target ? key : 'value'\n\n  function get() {\n    bindTargetKeyWithCurrentReaction({\n      target: context,\n      key: property,\n      type: 'get',\n    })\n    return store.value\n  }\n\n  function set(value: any) {\n    const oldValue = store.value\n    store.value = value\n    if (oldValue !== value) {\n      runReactionsFromTargetKey({\n        target: context,\n        key: property,\n        type: 'set',\n        oldValue,\n        value,\n      })\n    }\n  }\n  if (target) {\n    Object.defineProperty(target, key, {\n      get,\n      set,\n      enumerable: true,\n    })\n    return target\n  } else {\n    Object.defineProperty(proxy, 'value', {\n      set,\n      get,\n    })\n    buildDataTree(target, key, store)\n    ProxyRaw.set(proxy, store)\n    RawProxy.set(store, proxy)\n  }\n  return proxy\n})\n", "import { createAnnotation, createObservable } from '../internals'\nimport {\n  bindTargetKeyWithCurrentReaction,\n  runReactionsFromTargetKey,\n} from '../reaction'\nimport { IObservable } from './observable'\n\nexport const shallow: IObservable = createAnnotation(\n  ({ target, key, value }) => {\n    const store = {\n      value: createObservable(target, key, target ? target[key] : value, true),\n    }\n\n    function get() {\n      bindTargetKeyWithCurrentReaction({\n        target: target,\n        key: key,\n        type: 'get',\n      })\n      return store.value\n    }\n\n    function set(value: any) {\n      const oldValue = store.value\n      value = createObservable(target, key, value, true)\n      store.value = value\n      if (oldValue === value) return\n      runReactionsFromTargetKey({\n        target: target,\n        key: key,\n        type: 'set',\n        oldValue,\n        value,\n      })\n    }\n    if (target) {\n      Object.defineProperty(target, key, {\n        set,\n        get,\n        enumerable: true,\n        configurable: false,\n      })\n      return target\n    }\n    return store.value\n  }\n)\n", "import { ProxyRaw, RawProxy, ReactionStack } from '../environment'\nimport { createAnnotation } from '../internals'\nimport { buildDataTree } from '../tree'\nimport { isFn } from '../checkers'\nimport {\n  bindTargetKeyWithCurrentReaction,\n  runReactionsFromTargetKey,\n  bindComputedReactions,\n  hasRunningReaction,\n  isUntracking,\n  batchStart,\n  batchEnd,\n  releaseBindingReactions,\n} from '../reaction'\n\ninterface IValue<T = any> {\n  value?: T\n}\nexport interface IComputed {\n  <T>(compute: () => T): IValue<T>\n  <T>(compute: { get?: () => T; set?: (value: T) => void }): IValue<T>\n}\n\nconst getDescriptor = Object.getOwnPropertyDescriptor\n\nconst getProto = Object.getPrototypeOf\n\nfunction getGetterAndSetter(target: any, key: PropertyKey, value: any) {\n  if (!target) {\n    if (value) {\n      if (isFn(value)) {\n        return [value]\n      } else {\n        return [value.get, value.set]\n      }\n    }\n    return []\n  }\n  const descriptor = getDescriptor(target, key)\n  if (descriptor) return [descriptor.get, descriptor.set]\n  return getGetterAndSetter(getProto(target), key, value)\n}\n\nexport const computed: IComputed = createAnnotation(\n  ({ target, key, value }) => {\n    const store: IValue = {}\n\n    const proxy = {}\n\n    const context = target ? target : store\n    const property = target ? key : 'value'\n    const [getter, setter] = getGetterAndSetter(context, property, value)\n\n    function compute() {\n      store.value = getter?.call(context)\n    }\n    function reaction() {\n      if (ReactionStack.indexOf(reaction) === -1) {\n        releaseBindingReactions(reaction)\n        try {\n          ReactionStack.push(reaction)\n          compute()\n        } finally {\n          ReactionStack.pop()\n        }\n      }\n    }\n    reaction._name = 'ComputedReaction'\n    reaction._scheduler = () => {\n      reaction._dirty = true\n      runReactionsFromTargetKey({\n        target: context,\n        key: property,\n        value: store.value,\n        type: 'set',\n      })\n    }\n    reaction._isComputed = true\n    reaction._dirty = true\n    reaction._context = context\n    reaction._property = property\n\n    function get() {\n      if (hasRunningReaction()) {\n        bindComputedReactions(reaction)\n      }\n      if (!isUntracking()) {\n        //\u5982\u679C\u5141\u8BB8untracked\u8FC7\u7A0B\u4E2D\u6536\u96C6\u4F9D\u8D56\uFF0C\u90A3\u4E48\u6C38\u8FDC\u4E0D\u4F1A\u5B58\u5728\u7ED1\u5B9A\uFF0C\u56E0\u4E3A_dirty\u5DF2\u7ECF\u8BBE\u7F6E\u4E3Afalse\n        if (reaction._dirty) {\n          reaction()\n          reaction._dirty = false\n        }\n      } else {\n        compute()\n      }\n      bindTargetKeyWithCurrentReaction({\n        target: context,\n        key: property,\n        type: 'get',\n      })\n      return store.value\n    }\n\n    function set(value: any) {\n      try {\n        batchStart()\n        setter?.call(context, value)\n      } finally {\n        batchEnd()\n      }\n    }\n    if (target) {\n      Object.defineProperty(target, key, {\n        get,\n        set,\n        enumerable: true,\n      })\n      return target\n    } else {\n      Object.defineProperty(proxy, 'value', {\n        set,\n        get,\n      })\n      buildDataTree(target, key, store)\n      ProxyRaw.set(proxy, store)\n      RawProxy.set(store, proxy)\n    }\n    return proxy\n  }\n)\n", "import { isFn } from './checkers'\nimport { buildDataTree } from './tree'\nimport { observable } from './observable'\nimport { getObservableMaker } from './internals'\nimport { isObservable, isAnnotation, isSupportObservable } from './externals'\nimport { Annotations } from './types'\nimport { action } from './action'\nimport { ProxyRaw, RawProxy } from './environment'\n\nexport function define<Target extends object = any>(\n  target: Target,\n  annotations?: Annotations<Target>\n): Target {\n  if (isObservable(target)) return target\n  if (!isSupportObservable(target)) return target\n  buildDataTree(undefined, undefined, target)\n  ProxyRaw.set(target, target)\n  RawProxy.set(target, target)\n  for (const key in annotations) {\n    const annotation = annotations[key]\n    if (isAnnotation(annotation)) {\n      getObservableMaker(annotation)({\n        target,\n        key,\n      })\n    }\n  }\n  return target\n}\n\nexport function model<Target extends object = any>(target: Target): Target {\n  const annotations = Object.keys(target || {}).reduce((buf, key) => {\n    const descriptor = Object.getOwnPropertyDescriptor(target, key)\n    if (descriptor && descriptor.get) {\n      buf[key] = observable.computed\n    } else if (isFn(target[key])) {\n      buf[key] = action\n    } else {\n      buf[key] = observable\n    }\n    return buf\n  }, {})\n  return define(target, annotations)\n}\n", "import { IOperation } from './types'\nimport { ProxyRaw, ObserverListeners } from './environment'\nimport { isFn } from './checkers'\nimport { DataChange, getDataNode } from './tree'\n\nexport const observe = (\n  target: object,\n  observer?: (change: DataChange) => void,\n  deep = true\n) => {\n  const addListener = (target: any) => {\n    const raw = ProxyRaw.get(target) || target\n    const node = getDataNode(raw)\n\n    const listener = (operation: IOperation) => {\n      const targetRaw = ProxyRaw.get(operation.target) || operation.target\n      const targetNode = getDataNode(targetRaw)\n      if (deep) {\n        if (node.contains(targetNode)) {\n          observer(new DataChange(operation, targetNode))\n          return\n        }\n      }\n      if (\n        node === targetNode ||\n        (node.targetRaw === targetRaw && node.key === operation.key)\n      ) {\n        observer(new DataChange(operation, targetNode))\n      }\n    }\n\n    if (node && isFn(observer)) {\n      ObserverListeners.add(listener)\n    }\n    return () => {\n      ObserverListeners.delete(listener)\n    }\n  }\n  if (target && typeof target !== 'object')\n    throw Error(`Can not observe ${typeof target} type.`)\n  return addListener(target)\n}\n", "import { ArraySet } from './array'\n\nexport * from './tree'\n\nexport type PropertyKey = string | number | symbol\n\nexport type OperationType =\n  | 'add'\n  | 'delete'\n  | 'clear'\n  | 'set'\n  | 'get'\n  | 'iterate'\n  | 'has'\nexport interface IOperation {\n  target?: any\n  oldTarget?: any\n  key?: PropertyKey\n  value?: any\n  oldValue?: any\n  type?: OperationType\n  receiver?: any\n}\n\nexport interface IChange {\n  key?: PropertyKey\n  path?: ObservablePath\n  value?: any\n  oldValue?: any\n  type?: OperationType\n}\n\nexport interface IEffectQueueItem {\n  dispose?: void | Dispose\n  deps?: any[]\n}\n\nexport interface IMemoQueueItem {\n  value?: any\n  deps?: any[]\n}\n\nexport interface IVisitor<Value = any, Target = any> {\n  target?: Target\n  key?: PropertyKey\n  value?: Value\n}\n\nexport type Annotation = (...args: any[]) => any\n\nexport type Annotations<T = any> = {\n  [key in keyof T]?: Annotation\n}\n\nexport type ObservableListener = (operation: IOperation) => void\n\nexport type ObservablePath = Array<string | number>\n\nexport type Dispose = () => void\n\nexport type Effect = () => void | Dispose\n\nexport type Reaction = ((...args: any[]) => any) & {\n  _boundary?: number\n  _name?: string\n  _isComputed?: boolean\n  _dirty?: boolean\n  _context?: any\n  _disposed?: boolean\n  _property?: PropertyKey\n  _computesSet?: ArraySet<Reaction>\n  _reactionsSet?: ArraySet<ReactionsMap>\n  _scheduler?: (reaction: Reaction) => void\n  _memos?: {\n    queue: IMemoQueueItem[]\n    cursor: number\n  }\n  _effects?: {\n    queue: IEffectQueueItem[]\n    cursor: number\n  }\n}\n\nexport type ReactionsMap = Map<PropertyKey, ArraySet<Reaction>>\n\nexport interface IReactionOptions<T> {\n  name?: string\n  equals?: (oldValue: T, newValue: T) => boolean\n  fireImmediately?: boolean\n}\n\nexport type BindFunction<F = (...args: any[]) => any> = (\n  callback?: F,\n  context?: any\n) => F\n\nexport type BoundaryFunction = <F extends (...args: any) => any>(\n  fn?: F\n) => ReturnType<F>\n\nexport interface IBoundable {\n  bound?: <T extends (...args: any[]) => any>(callback: T, context?: any) => T //\u9AD8\u9636\u7ED1\u5B9A\n}\nexport interface IAction extends IBoundable {\n  <T>(callback?: () => T): T //\u539F\u5730action\n  scope?: (<T>(callback?: () => T) => T) & IBoundable //\u539F\u5730\u5C40\u90E8action\n}\n\nexport interface IBatch extends IAction {\n  endpoint?: (callback?: () => void) => void\n}\n"],
  "mappings": "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",
  "names": []
}
