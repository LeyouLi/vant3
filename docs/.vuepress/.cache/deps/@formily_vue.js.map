{
  "version": 3,
  "sources": ["dep:@formily_vue", "../../../../node_modules/@formily/vue/src/index.ts", "../../../../node_modules/@formily/json-schema/src/index.ts", "../../../../node_modules/@formily/json-schema/src/schema.ts", "../../../../node_modules/@formily/json-schema/src/compiler.ts", "../../../../node_modules/@formily/json-schema/src/shared.ts", "../../../../node_modules/@formily/json-schema/src/transformer.ts", "../../../../node_modules/@formily/json-schema/src/patches.ts", "../../../../node_modules/@formily/json-schema/src/polyfills/index.ts", "../../../../node_modules/@formily/json-schema/src/polyfills/SPECIFICATION_1_0.ts", "../../../../node_modules/@formily/json-schema/esm/types.js", "../../../../node_modules/@formily/vue/src/components/index.ts", "../../../../node_modules/@formily/vue/src/components/FormProvider.ts", "../../../../node_modules/@formily/vue/node_modules/vue-demi/lib/index.esm.js", "../../../../node_modules/@formily/vue/src/shared/context.ts", "../../../../node_modules/@formily/vue/src/hooks/useAttach.ts", "../../../../node_modules/@formily/vue/src/hooks/useInjectionCleaner.ts", "../../../../node_modules/vue-frag/dist/frag.esm.js", "../../../../node_modules/@formily/vue/src/shared/fragment.ts", "../../../../node_modules/@formily/vue/src/utils/formatVNodeData.ts", "../../../../node_modules/@formily/vue/src/shared/h.ts", "../../../../node_modules/@formily/vue/src/components/FormConsumer.ts", "../../../../node_modules/@formily/vue/src/hooks/index.ts", "../../../../node_modules/@formily/vue/src/hooks/useForm.ts", "../../../../node_modules/@formily/vue/src/hooks/useField.ts", "../../../../node_modules/@formily/vue/src/hooks/useFormEffects.ts", "../../../../node_modules/@formily/vue/src/hooks/useFieldSchema.ts", "../../../../node_modules/@formily/vue/src/hooks/useParentForm.ts", "../../../../node_modules/@formily/vue/src/shared/index.ts", "../../../../node_modules/@formily/vue/src/shared/connect.ts", "../../../../node_modules/@formily/vue/src/shared/createForm.ts", "../../../../node_modules/@formily/vue/src/components/ReactiveField.ts", "../../../../node_modules/@formily/vue/src/utils/getRawComponent.ts", "../../../../node_modules/@formily/vue/src/utils/getFieldProps.ts", "../../../../node_modules/@formily/vue/src/components/ArrayField.ts", "../../../../node_modules/@formily/vue/src/components/ObjectField.ts", "../../../../node_modules/@formily/vue/src/components/VoidField.ts", "../../../../node_modules/@formily/vue/src/components/Field.ts", "../../../../node_modules/@formily/vue/src/components/RecursionField.ts", "../../../../node_modules/@formily/vue/src/utils/resolveSchemaProps.ts", "../../../../node_modules/@formily/vue/src/components/SchemaField.ts", "../../../../node_modules/@formily/vue/src/components/ExpressionScope.ts", "../../../../node_modules/@formily/vue/src/types/index.ts", "../../../../node_modules/@formily/vue/src/vue2-components.ts"],
  "sourcesContent": ["\nexport * from \"../../../../node_modules/@formily/vue/esm/index.js\"", "export * from '@formily/json-schema'\nexport * from './components'\nexport * from './shared'\nexport * from './hooks'\nexport * from './types'\nexport * as Vue2Components from './vue2-components'\n", "export * from './schema'\nexport * from './types'\n", "import {\n  ISchema,\n  SchemaEnum,\n  SchemaProperties,\n  SchemaReaction,\n  SchemaTypes,\n  SchemaKey,\n  ISchemaTransformerOptions,\n} from './types'\nimport { IFieldFactoryProps } from '@formily/core'\nimport { map, each, isFn, instOf, FormPath, isStr } from '@formily/shared'\nimport { compile, silent, shallowCompile, registerCompiler } from './compiler'\nimport { transformFieldProps } from './transformer'\nimport {\n  reducePatches,\n  registerPatches,\n  registerPolyfills,\n  enablePolyfills,\n} from './patches'\nimport {\n  registerVoidComponents,\n  registerTypeDefaultComponents,\n} from './polyfills'\nimport { SchemaNestedMap } from './shared'\n\nexport class Schema<\n  Decorator = any,\n  Component = any,\n  DecoratorProps = any,\n  ComponentProps = any,\n  Pattern = any,\n  Display = any,\n  Validator = any,\n  Message = any,\n  ReactionField = any\n> implements ISchema\n{\n  parent?: Schema\n  root?: Schema\n  name?: SchemaKey\n  title?: Message\n  description?: Message\n  default?: any\n  readOnly?: boolean\n  writeOnly?: boolean\n  type?: SchemaTypes\n  enum?: SchemaEnum<Message>\n  const?: any\n  multipleOf?: number\n  maximum?: number\n  exclusiveMaximum?: number\n  minimum?: number\n  exclusiveMinimum?: number\n  maxLength?: number\n  minLength?: number\n  pattern?: string | RegExp\n  maxItems?: number\n  minItems?: number\n  uniqueItems?: boolean\n  maxProperties?: number\n  minProperties?: number\n  required?: string[] | boolean | string\n  format?: string\n  /** nested json schema spec **/\n  definitions?: Record<\n    string,\n    Schema<\n      Decorator,\n      Component,\n      DecoratorProps,\n      ComponentProps,\n      Pattern,\n      Display,\n      Validator,\n      Message\n    >\n  >\n  properties?: Record<\n    string,\n    Schema<\n      Decorator,\n      Component,\n      DecoratorProps,\n      ComponentProps,\n      Pattern,\n      Display,\n      Validator,\n      Message\n    >\n  >\n  items?:\n    | Schema<\n        Decorator,\n        Component,\n        DecoratorProps,\n        ComponentProps,\n        Pattern,\n        Display,\n        Validator,\n        Message\n      >\n    | Schema<\n        Decorator,\n        Component,\n        DecoratorProps,\n        ComponentProps,\n        Pattern,\n        Display,\n        Validator,\n        Message\n      >[]\n  additionalItems?: Schema<\n    Decorator,\n    Component,\n    DecoratorProps,\n    ComponentProps,\n    Pattern,\n    Display,\n    Validator,\n    Message\n  >\n  patternProperties?: Record<\n    string,\n    Schema<\n      Decorator,\n      Component,\n      DecoratorProps,\n      ComponentProps,\n      Pattern,\n      Display,\n      Validator,\n      Message\n    >\n  >\n  additionalProperties?: Schema<\n    Decorator,\n    Component,\n    DecoratorProps,\n    ComponentProps,\n    Pattern,\n    Display,\n    Validator,\n    Message\n  >;\n\n  //\u987A\u5E8F\u63CF\u8FF0\n  ['x-index']?: number;\n  //\u4EA4\u4E92\u6A21\u5F0F\n  ['x-pattern']?: Pattern;\n  //\u5C55\u793A\u72B6\u6001\n  ['x-display']?: Display;\n  //\u6821\u9A8C\u5668\n  ['x-validator']?: Validator;\n  //\u88C5\u9970\u5668\n  ['x-decorator']?: Decorator;\n  //\u88C5\u9970\u5668\u5C5E\u6027\n  ['x-decorator-props']?: DecoratorProps;\n  //\u7EC4\u4EF6\n  ['x-component']?: Component;\n  //\u7EC4\u4EF6\u5C5E\u6027\n  ['x-component-props']?: ComponentProps;\n\n  ['x-reactions']?: SchemaReaction<ReactionField>[];\n\n  ['x-content']?: any;\n\n  ['x-data']?: any;\n\n  ['x-visible']?: boolean;\n\n  ['x-hidden']?: boolean;\n\n  ['x-disabled']?: boolean;\n\n  ['x-editable']?: boolean;\n\n  ['x-read-only']?: boolean;\n\n  ['x-read-pretty']?: boolean;\n\n  [key: `x-${string | number}` | symbol]: any\n\n  _isJSONSchemaObject = true\n\n  version = '2.0'\n\n  constructor(\n    json: ISchema<\n      Decorator,\n      Component,\n      DecoratorProps,\n      ComponentProps,\n      Pattern,\n      Display,\n      Validator,\n      Message\n    >,\n    parent?: Schema\n  ) {\n    if (parent) {\n      this.parent = parent\n      this.root = parent.root\n    } else {\n      this.root = this\n    }\n    return this.fromJSON(json)\n  }\n\n  addProperty = (\n    key: SchemaKey,\n    schema: ISchema<\n      Decorator,\n      Component,\n      DecoratorProps,\n      ComponentProps,\n      Pattern,\n      Display,\n      Validator,\n      Message\n    >\n  ) => {\n    this.properties = this.properties || {}\n    this.properties[key] = new Schema(schema, this)\n    this.properties[key].name = key\n    return this.properties[key]\n  }\n\n  removeProperty = (key: SchemaKey) => {\n    const schema = this.properties[key]\n    delete this.properties[key]\n    return schema\n  }\n\n  setProperties = (\n    properties: SchemaProperties<\n      Decorator,\n      Component,\n      DecoratorProps,\n      ComponentProps,\n      Pattern,\n      Display,\n      Validator,\n      Message\n    >\n  ) => {\n    for (const key in properties) {\n      this.addProperty(key, properties[key])\n    }\n    return this\n  }\n\n  addPatternProperty = (\n    key: SchemaKey,\n    schema: ISchema<\n      Decorator,\n      Component,\n      DecoratorProps,\n      ComponentProps,\n      Pattern,\n      Display,\n      Validator,\n      Message\n    >\n  ) => {\n    if (!schema) return\n    this.patternProperties = this.patternProperties || {}\n    this.patternProperties[key] = new Schema(schema, this)\n    this.patternProperties[key].name = key\n    return this.patternProperties[key]\n  }\n\n  removePatternProperty = (key: SchemaKey) => {\n    const schema = this.patternProperties[key]\n    delete this.patternProperties[key]\n    return schema\n  }\n\n  setPatternProperties = (\n    properties: SchemaProperties<\n      Decorator,\n      Component,\n      DecoratorProps,\n      ComponentProps,\n      Pattern,\n      Display,\n      Validator,\n      Message\n    >\n  ) => {\n    if (!properties) return this\n    for (const key in properties) {\n      this.addPatternProperty(key, properties[key])\n    }\n    return this\n  }\n\n  setAdditionalProperties = (\n    properties: ISchema<\n      Decorator,\n      Component,\n      DecoratorProps,\n      ComponentProps,\n      Pattern,\n      Display,\n      Validator,\n      Message\n    >\n  ) => {\n    if (!properties) return\n    this.additionalProperties = new Schema(properties)\n    return this.additionalProperties\n  }\n\n  setItems = (\n    schema:\n      | ISchema<\n          Decorator,\n          Component,\n          DecoratorProps,\n          ComponentProps,\n          Pattern,\n          Display,\n          Validator,\n          Message\n        >\n      | ISchema<\n          Decorator,\n          Component,\n          DecoratorProps,\n          ComponentProps,\n          Pattern,\n          Display,\n          Validator,\n          Message\n        >[]\n  ) => {\n    if (!schema) return\n    if (Array.isArray(schema)) {\n      this.items = schema.map((item) => new Schema(item, this))\n    } else {\n      this.items = new Schema(schema, this)\n    }\n    return this.items\n  }\n\n  setAdditionalItems = (\n    items: ISchema<\n      Decorator,\n      Component,\n      DecoratorProps,\n      ComponentProps,\n      Pattern,\n      Display,\n      Validator,\n      Message\n    >\n  ) => {\n    if (!items) return\n    this.additionalItems = new Schema(items, this)\n    return this.additionalItems\n  }\n\n  findDefinitions = (ref: string) => {\n    if (!ref || !this.root || !isStr(ref)) return\n    if (ref.indexOf('#/') !== 0) return\n    return FormPath.getIn(this.root, ref.substring(2).split('/'))\n  }\n\n  mapProperties = <T>(\n    callback?: (\n      schema: Schema<\n        Decorator,\n        Component,\n        DecoratorProps,\n        ComponentProps,\n        Pattern,\n        Display,\n        Validator,\n        Message\n      >,\n      key: SchemaKey,\n      index: number\n    ) => T\n  ): T[] => {\n    return Schema.getOrderProperties(this).map(({ schema, key }, index) => {\n      return callback(schema, key, index)\n    })\n  }\n\n  mapPatternProperties = <T>(\n    callback?: (\n      schema: Schema<\n        Decorator,\n        Component,\n        DecoratorProps,\n        ComponentProps,\n        Pattern,\n        Display,\n        Validator,\n        Message\n      >,\n      key: SchemaKey,\n      index: number\n    ) => T\n  ): T[] => {\n    return Schema.getOrderProperties(this, 'patternProperties').map(\n      ({ schema, key }, index) => {\n        return callback(schema, key, index)\n      }\n    )\n  }\n\n  reduceProperties = <P, R>(\n    callback?: (\n      buffer: P,\n      schema: Schema<\n        Decorator,\n        Component,\n        DecoratorProps,\n        ComponentProps,\n        Pattern,\n        Display,\n        Validator,\n        Message\n      >,\n      key: SchemaKey,\n      index: number\n    ) => R,\n    predicate?: P\n  ): R => {\n    let results: any = predicate\n    Schema.getOrderProperties(this, 'properties').forEach(\n      ({ schema, key }, index) => {\n        results = callback(results, schema, key, index)\n      }\n    )\n    return results\n  }\n\n  reducePatternProperties = <P, R>(\n    callback?: (\n      buffer: P,\n      schema: Schema<\n        Decorator,\n        Component,\n        DecoratorProps,\n        ComponentProps,\n        Pattern,\n        Display,\n        Validator,\n        Message\n      >,\n      key: SchemaKey,\n      index: number\n    ) => R,\n    predicate?: P\n  ): R => {\n    let results: any = predicate\n    Schema.getOrderProperties(this, 'patternProperties').forEach(\n      ({ schema, key }, index) => {\n        results = callback(results, schema, key, index)\n      }\n    )\n    return results\n  }\n\n  compile = (scope?: any) => {\n    const schema = new Schema({}, this.parent)\n    each(this, (value, key) => {\n      if (isFn(value) && !key.includes('x-')) return\n      if (key === 'parent' || key === 'root') return\n      if (!SchemaNestedMap[key]) {\n        schema[key] = value ? compile(value, scope) : value\n      } else {\n        schema[key] = value ? shallowCompile(value, scope) : value\n      }\n    })\n    return schema\n  }\n\n  fromJSON = (\n    json: ISchema<\n      Decorator,\n      Component,\n      DecoratorProps,\n      ComponentProps,\n      Pattern,\n      Display,\n      Validator,\n      Message\n    >\n  ) => {\n    if (!json) return this\n    if (Schema.isSchemaInstance(json)) return json\n    each(reducePatches(json), (value, key) => {\n      if (isFn(value) && !key.includes('x-')) return\n      if (key === 'properties') {\n        this.setProperties(value)\n      } else if (key === 'patternProperties') {\n        this.setPatternProperties(value)\n      } else if (key === 'additionalProperties') {\n        this.setAdditionalProperties(value)\n      } else if (key === 'items') {\n        this.setItems(value)\n      } else if (key === 'additionalItems') {\n        this.setAdditionalItems(value)\n      } else if (key === '$ref') {\n        this.fromJSON(this.findDefinitions(value))\n      } else {\n        this[key] = value\n      }\n    })\n    return this\n  }\n\n  toJSON = (\n    recursion = true\n  ): ISchema<\n    Decorator,\n    Component,\n    DecoratorProps,\n    ComponentProps,\n    Pattern,\n    Display,\n    Validator,\n    Message\n  > => {\n    const results = {}\n    each(this, (value: any, key) => {\n      if (\n        (isFn(value) && !key.includes('x-')) ||\n        key === 'parent' ||\n        key === 'root'\n      )\n        return\n      if (key === 'properties' || key === 'patternProperties') {\n        if (!recursion) return\n        results[key] = map(value, (item) => item?.toJSON?.())\n      } else if (key === 'additionalProperties' || key === 'additionalItems') {\n        if (!recursion) return\n        results[key] = value?.toJSON?.()\n      } else if (key === 'items') {\n        if (!recursion) return\n        if (Array.isArray(value)) {\n          results[key] = value.map((item) => item?.toJSON?.())\n        } else {\n          results[key] = value?.toJSON?.()\n        }\n      } else {\n        results[key] = value\n      }\n    })\n    return results\n  }\n\n  toFieldProps = (\n    options?: ISchemaTransformerOptions\n  ): IFieldFactoryProps<any, any> => {\n    return transformFieldProps(this, options)\n  }\n\n  static getOrderProperties = (\n    schema: ISchema = {},\n    propertiesName: keyof ISchema = 'properties'\n  ) => {\n    const orderProperties = []\n    const unorderProperties = []\n    for (const key in schema[propertiesName]) {\n      const item = schema[propertiesName][key]\n      const index = item['x-index']\n      if (!isNaN(index)) {\n        orderProperties[index] = { schema: item, key }\n      } else {\n        unorderProperties.push({ schema: item, key })\n      }\n    }\n    return orderProperties.concat(unorderProperties).filter((item) => !!item)\n  }\n\n  static compile = (expression: any, scope?: any) => {\n    return compile(expression, scope)\n  }\n\n  static shallowCompile = (expression: any, scope?: any) => {\n    return shallowCompile(expression, scope)\n  }\n\n  static isSchemaInstance = (value: any): value is Schema => {\n    return instOf(value, Schema)\n  }\n\n  static registerCompiler = registerCompiler\n\n  static registerPatches = registerPatches\n\n  static registerVoidComponents = registerVoidComponents\n\n  static registerTypeDefaultComponents = registerTypeDefaultComponents\n\n  static registerPolyfills = registerPolyfills\n\n  static enablePolyfills = enablePolyfills\n\n  static silent = silent\n}\n", "import {\n  isArr,\n  isFn,\n  isPlainObj,\n  isStr,\n  reduce,\n  FormPath,\n} from '@formily/shared'\nimport { IGeneralFieldState } from '@formily/core'\nimport { untracked, hasCollected } from '@formily/reactive'\nimport {\n  traverse,\n  traverseSchema,\n  isNoNeedCompileObject,\n  hasOwnProperty,\n  patchStateFormSchema,\n} from './shared'\nimport { ISchema } from './types'\n\nconst ExpRE = /^\\s*\\{\\{([\\s\\S]*)\\}\\}\\s*$/\nconst Registry = {\n  silent: false,\n  compile(expression: string, scope = {}) {\n    if (Registry.silent) {\n      try {\n        return new Function('$root', `with($root) { return (${expression}); }`)(\n          scope\n        )\n      } catch {}\n    } else {\n      return new Function('$root', `with($root) { return (${expression}); }`)(\n        scope\n      )\n    }\n  },\n}\n\nexport const silent = (value = true) => {\n  Registry.silent = !!value\n}\n\nexport const registerCompiler = (\n  compiler: (expression: string, scope: any) => any\n) => {\n  if (isFn(compiler)) {\n    Registry.compile = compiler\n  }\n}\n\nexport const shallowCompile = <Source = any, Scope = any>(\n  source: Source,\n  scope?: Scope\n) => {\n  if (isStr(source)) {\n    const matched = source.match(ExpRE)\n    if (!matched) return source\n    return Registry.compile(matched[1], scope)\n  }\n  return source\n}\n\nexport const compile = <Source = any, Scope = any>(\n  source: Source,\n  scope?: Scope\n): any => {\n  const seenObjects = []\n  const compile = (source: any) => {\n    if (isStr(source)) {\n      return shallowCompile(source, scope)\n    } else if (isArr(source)) {\n      return source.map((value: any) => compile(value))\n    } else if (isPlainObj(source)) {\n      if (isNoNeedCompileObject(source)) return source\n      const seenIndex = seenObjects.indexOf(source)\n      if (seenIndex > -1) {\n        return source\n      }\n      const addIndex = seenObjects.length\n      seenObjects.push(source)\n      const results = reduce(\n        source,\n        (buf, value, key) => {\n          buf[key] = compile(value)\n          return buf\n        },\n        {}\n      )\n      seenObjects.splice(addIndex, 1)\n      return results\n    }\n    return source\n  }\n  return compile(source)\n}\n\nexport const patchCompile = (\n  targetState: IGeneralFieldState,\n  sourceState: any,\n  scope: any\n) => {\n  traverse(sourceState, (value, pattern) => {\n    const path = FormPath.parse(pattern)\n    const compiled = compile(value, scope)\n    const key = path.segments[0]\n    if (compiled === undefined) return\n    if (hasOwnProperty.call(targetState, key)) {\n      untracked(() => FormPath.setIn(targetState, path, compiled))\n    }\n  })\n}\n\nexport const patchSchemaCompile = (\n  targetState: IGeneralFieldState,\n  sourceSchema: ISchema,\n  scope: any,\n  demand = false\n) => {\n  traverseSchema(sourceSchema, (value, path) => {\n    let compiled = value\n    let collected = hasCollected(() => {\n      compiled = compile(value, scope)\n    })\n    if (compiled === undefined) return\n    if (demand) {\n      if (collected || !targetState.initialized) {\n        patchStateFormSchema(targetState, path, compiled)\n      }\n    } else {\n      patchStateFormSchema(targetState, path, compiled)\n    }\n  })\n}\n", "import { isFn, each, isPlainObj, isArr, toArr, FormPath } from '@formily/shared'\nimport { isObservable, untracked } from '@formily/reactive'\nimport { Schema } from './schema'\nimport { ISchema } from './types'\n\nconst REVA_ACTIONS_KEY = Symbol.for('__REVA_ACTIONS')\n\nexport const SchemaNestedMap = {\n  parent: true,\n  root: true,\n  properties: true,\n  patternProperties: true,\n  additionalProperties: true,\n  items: true,\n  additionalItems: true,\n  'x-linkages': true,\n  'x-reactions': true,\n}\n\nexport const SchemaStateMap = {\n  title: 'title',\n  description: 'description',\n  default: 'initialValue',\n  enum: 'dataSource',\n  readOnly: 'readOnly',\n  writeOnly: 'editable',\n  'x-content': 'content',\n  'x-data': 'data',\n  'x-value': 'value',\n  'x-editable': 'editable',\n  'x-disabled': 'disabled',\n  'x-read-pretty': 'readPretty',\n  'x-read-only': 'readOnly',\n  'x-visible': 'visible',\n  'x-hidden': 'hidden',\n  'x-display': 'display',\n  'x-pattern': 'pattern',\n  'x-validator': 'validator',\n  'x-decorator': 'decoratorType',\n  'x-component': 'componentType',\n  'x-decorator-props': 'decoratorProps',\n  'x-component-props': 'componentProps',\n}\n\nexport const SchemaValidatorMap = {\n  required: true,\n  format: true,\n  maxItems: true,\n  minItems: true,\n  maxLength: true,\n  minLength: true,\n  maximum: true,\n  minimum: true,\n  exclusiveMaximum: true,\n  exclusiveMinimum: true,\n  pattern: true,\n  const: true,\n  multipleOf: true,\n  maxProperties: true,\n  minProperties: true,\n  uniqueItems: true,\n}\n\nexport const SchemaNormalKeys = Object.keys(SchemaStateMap)\n\nexport const SchemaValidatorKeys = Object.keys(SchemaValidatorMap)\n\nexport const hasOwnProperty = Object.prototype.hasOwnProperty\n\nexport const traverse = (\n  target: any,\n  visitor: (value: any, path: Array<string | number>) => void\n) => {\n  const seenObjects = []\n  const root = target\n  const traverse = (target: any, path = []) => {\n    if (isPlainObj(target)) {\n      const seenIndex = seenObjects.indexOf(target)\n      if (seenIndex > -1) {\n        return\n      }\n      const addIndex = seenObjects.length\n      seenObjects.push(target)\n      if (isNoNeedCompileObject(target) && root !== target) {\n        visitor(target, path)\n        return\n      }\n      each(target, (value, key) => {\n        traverse(value, path.concat(key))\n      })\n      seenObjects.splice(addIndex, 1)\n    } else {\n      visitor(target, path)\n    }\n  }\n  traverse(target)\n}\n\nexport const traverseSchema = (\n  schema: ISchema,\n  visitor: (value: any, path: any[]) => void\n) => {\n  if (schema['x-validator'] !== undefined) {\n    visitor(schema['x-validator'], ['x-validator'])\n  }\n  const seenObjects = []\n  const root = schema\n  const traverse = (target: any, path = []) => {\n    if (\n      path[0] === 'x-validator' ||\n      path[0] === 'version' ||\n      path[0] === '_isJSONSchemaObject'\n    )\n      return\n    if (String(path[0]).indexOf('x-') == -1 && isFn(target)) return\n    if (SchemaNestedMap[path[0]]) return\n    if (isPlainObj(target)) {\n      if (path[0] === 'default' || path[0] === 'x-value') {\n        visitor(target, path)\n        return\n      }\n      const seenIndex = seenObjects.indexOf(target)\n      if (seenIndex > -1) {\n        return\n      }\n      const addIndex = seenObjects.length\n      seenObjects.push(target)\n      if (isNoNeedCompileObject(target) && root !== target) {\n        visitor(target, path)\n        return\n      }\n      each(target, (value, key) => {\n        traverse(value, path.concat(key))\n      })\n      seenObjects.splice(addIndex, 1)\n    } else {\n      visitor(target, path)\n    }\n  }\n  traverse(schema)\n}\n\nexport const isNoNeedCompileObject = (source: any) => {\n  if ('$$typeof' in source && '_owner' in source) {\n    return true\n  }\n  if (source['_isAMomentObject']) {\n    return true\n  }\n  if (Schema.isSchemaInstance(source)) {\n    return true\n  }\n  if (source[REVA_ACTIONS_KEY]) {\n    return true\n  }\n  if (isFn(source['toJS'])) {\n    return true\n  }\n  if (isFn(source['toJSON'])) {\n    return true\n  }\n  if (isObservable(source)) {\n    return true\n  }\n  return false\n}\n\nexport const createDataSource = (source: any[]) => {\n  return toArr(source).map((item) => {\n    if (typeof item === 'object') {\n      return item\n    } else {\n      return {\n        label: item,\n        value: item,\n      }\n    }\n  })\n}\n\nexport const patchStateFormSchema = (\n  targetState: any,\n  pattern: any[],\n  compiled: any\n) => {\n  untracked(() => {\n    const path = FormPath.parse(pattern)\n    const segments = path.segments\n    const key = segments[0]\n    const isEnum = key === 'enum' && isArr(compiled)\n    const schemaMapKey = SchemaStateMap[key]\n    if (schemaMapKey) {\n      FormPath.setIn(\n        targetState,\n        [schemaMapKey].concat(segments.slice(1)),\n        isEnum ? createDataSource(compiled) : compiled\n      )\n    } else {\n      const isValidatorKey = SchemaValidatorMap[key]\n      if (isValidatorKey) {\n        targetState['setValidatorRule']?.(key, compiled)\n      }\n    }\n  })\n}\n", "import { untracked, autorun, observable } from '@formily/reactive'\nimport {\n  isArr,\n  isStr,\n  toArr,\n  each,\n  isFn,\n  isPlainObj,\n  reduce,\n} from '@formily/shared'\nimport { Schema } from './schema'\nimport {\n  ISchema,\n  ISchemaTransformerOptions,\n  IFieldStateSetterOptions,\n  SchemaReaction,\n} from './types'\nimport {\n  onFieldInit,\n  onFieldMount,\n  onFieldUnmount,\n  onFieldValueChange,\n  onFieldInputValueChange,\n  onFieldInitialValueChange,\n  onFieldValidateStart,\n  onFieldValidateEnd,\n  onFieldValidateFailed,\n  onFieldValidateSuccess,\n  IFieldFactoryProps,\n  Field,\n} from '@formily/core'\nimport { patchCompile, patchSchemaCompile, shallowCompile } from './compiler'\n\nconst FieldEffects = {\n  onFieldInit,\n  onFieldMount,\n  onFieldUnmount,\n  onFieldValueChange,\n  onFieldInputValueChange,\n  onFieldInitialValueChange,\n  onFieldValidateStart,\n  onFieldValidateEnd,\n  onFieldValidateFailed,\n  onFieldValidateSuccess,\n}\n\nconst DefaultFieldEffects = ['onFieldInit', 'onFieldValueChange']\n\nconst getDependencyValue = (\n  field: Field,\n  pattern: string,\n  property?: string\n) => {\n  const [target, path] = String(pattern).split(/\\s*#\\s*/)\n  return field.query(target).getIn(path || property || 'value')\n}\n\nconst getDependencies = (\n  field: Field,\n  dependencies:\n    | Array<string | { name?: string; source?: string; property?: string }>\n    | object\n) => {\n  if (isArr(dependencies)) {\n    const results = []\n    dependencies.forEach((pattern) => {\n      if (isStr(pattern)) {\n        results.push(getDependencyValue(field, pattern))\n      } else if (isPlainObj(pattern)) {\n        if (pattern.name && pattern.source) {\n          results[pattern.name] = getDependencyValue(\n            field,\n            pattern.source,\n            pattern.property\n          )\n        }\n      }\n    })\n    return results\n  } else if (isPlainObj(dependencies)) {\n    return reduce(\n      dependencies,\n      (buf, pattern, key) => {\n        buf[key] = getDependencyValue(field, pattern)\n        return buf\n      },\n      {}\n    )\n  }\n  return []\n}\n\nconst setSchemaFieldState = (\n  options: IFieldStateSetterOptions,\n  demand = false\n) => {\n  const { request, target, runner, field, scope } = options || {}\n  if (!request) return\n  if (target) {\n    if (request.state) {\n      field.form.setFieldState(target, (state) =>\n        patchCompile(state, request.state, {\n          ...scope,\n          $target: state,\n        })\n      )\n    }\n    if (request.schema) {\n      field.form.setFieldState(target, (state) =>\n        patchSchemaCompile(\n          state,\n          request.schema,\n          {\n            ...scope,\n            $target: state,\n          },\n          demand\n        )\n      )\n    }\n    if (isStr(runner) && runner) {\n      field.form.setFieldState(target, (state) => {\n        shallowCompile(`{{function(){${runner}}}}`, {\n          ...scope,\n          $target: state,\n        })()\n      })\n    }\n  } else {\n    if (request.state) {\n      field.setState((state) => patchCompile(state, request.state, scope))\n    }\n    if (request.schema) {\n      field.setState((state) =>\n        patchSchemaCompile(state, request.schema, scope, demand)\n      )\n    }\n    if (isStr(runner) && runner) {\n      shallowCompile(`{{function(){${runner}}}}`, scope)()\n    }\n  }\n}\n\nconst getBaseScope = (\n  field: Field,\n  options: ISchemaTransformerOptions = {}\n) => {\n  const $observable = (target: any, deps?: any[]) =>\n    autorun.memo(() => observable(target), deps)\n  const $props = (props: any) => field.setComponentProps(props)\n  const $effect = autorun.effect\n  const $memo = autorun.memo\n  const $self = field\n  const $form = field.form\n  const $values = field.form.values\n  return {\n    ...options.scope,\n    $form,\n    $self,\n    $observable,\n    $effect,\n    $memo,\n    $props,\n    $values,\n  }\n}\n\nconst getBaseReactions =\n  (schema: ISchema, options: ISchemaTransformerOptions) => (field: Field) => {\n    setSchemaFieldState(\n      {\n        field,\n        request: { schema },\n        scope: getBaseScope(field, options),\n      },\n      true\n    )\n  }\n\nconst getUserReactions = (\n  schema: ISchema,\n  options: ISchemaTransformerOptions\n) => {\n  const reactions: SchemaReaction[] = toArr(schema['x-reactions'])\n  return reactions.map((unCompiled) => {\n    return (field: Field) => {\n      const baseScope = getBaseScope(field, options)\n      const reaction = shallowCompile(unCompiled, baseScope)\n      if (!reaction) return\n      if (isFn(reaction)) {\n        return reaction(field, baseScope)\n      }\n      const { when, fulfill, otherwise, target, effects } = reaction\n      const run = () => {\n        const $deps = getDependencies(field, reaction.dependencies)\n        const $dependencies = $deps\n        const scope = {\n          ...baseScope,\n          $target: null,\n          $deps,\n          $dependencies,\n        }\n        const compiledWhen = shallowCompile(when, scope)\n        const condition = when ? compiledWhen : true\n        const request = condition ? fulfill : otherwise\n        const runner = condition ? fulfill?.run : otherwise?.run\n        setSchemaFieldState({\n          field,\n          target,\n          request,\n          runner,\n          scope,\n        })\n      }\n\n      if (target) {\n        reaction.effects = effects?.length ? effects : DefaultFieldEffects\n      }\n      if (reaction.effects) {\n        autorun.memo(() => {\n          untracked(() => {\n            each(reaction.effects, (type) => {\n              if (FieldEffects[type]) {\n                FieldEffects[type](field.address, run)\n              }\n            })\n          })\n        }, [])\n      } else {\n        run()\n      }\n    }\n  })\n}\n\nexport const transformFieldProps = (\n  schema: Schema,\n  options: ISchemaTransformerOptions\n): IFieldFactoryProps<any, any> => {\n  return {\n    name: schema.name,\n    reactions: [getBaseReactions(schema, options)].concat(\n      getUserReactions(schema, options)\n    ),\n  }\n}\n", "import { isFn, isArr } from '@formily/shared'\nimport { SchemaPatch } from './types'\n\nconst patches: SchemaPatch[] = []\n\nconst polyfills: Record<string, SchemaPatch[]> = {}\n\nexport const reducePatches = (schema: any) => {\n  return patches.reduce(\n    (buf, patch) => {\n      return patch(buf)\n    },\n    { ...schema }\n  )\n}\n\nexport const registerPatches = (...args: SchemaPatch[]) => {\n  args.forEach((patch) => {\n    if (isFn(patch)) {\n      patches.push(patch)\n    }\n  })\n}\n\nexport const registerPolyfills = (version: string, patch: SchemaPatch) => {\n  if (version && isFn(patch)) {\n    polyfills[version] = polyfills[version] || []\n    polyfills[version].push(patch)\n  }\n}\n\nexport const enablePolyfills = (versions?: string[]) => {\n  if (isArr(versions)) {\n    versions.forEach((version) => {\n      if (isArr(polyfills[version])) {\n        polyfills[version].forEach((patch) => {\n          registerPatches(patch)\n        })\n      }\n    })\n  }\n}\n", "export * from './SPECIFICATION_1_0'\n", "import { registerPolyfills } from '../patches'\nimport { toArr, isArr, isStr, lowerCase, isValid } from '@formily/shared'\nimport { ISchema } from '../types'\n\nconst VOID_COMPONENTS = [\n  'card',\n  'block',\n  'grid-col',\n  'grid-row',\n  'grid',\n  'layout',\n  'step',\n  'tab',\n  'text-box',\n]\n\nconst TYPE_DEFAULT_COMPONENTS = {}\n\nconst transformCondition = (condition: string) => {\n  if (isStr(condition)) {\n    return condition.replace(/\\$value/, '$self.value')\n  }\n}\n\nconst transformXLinkage = (linkages: any[]) => {\n  if (isArr(linkages)) {\n    return linkages.reduce((buf, item) => {\n      if (!item) return buf\n      if (item.type === 'value:visible') {\n        return buf.concat({\n          target: item.target,\n          when: transformCondition(item.condition),\n          fulfill: {\n            state: {\n              visible: true,\n            },\n          },\n          otherwise: {\n            state: {\n              visible: false,\n            },\n          },\n        })\n      } else if (item.type === 'value:schema') {\n        return buf.concat({\n          target: item.target,\n          when: transformCondition(item.condition),\n          fulfill: {\n            schema: SpecificationV1Polyfill({ version: '1.0', ...item.schema }),\n          },\n          otherwise: {\n            schema: SpecificationV1Polyfill({\n              version: '1.0',\n              ...item.otherwise,\n            }),\n          },\n        })\n      } else if (item.type === 'value:state') {\n        return buf.concat({\n          target: item.target,\n          when: transformCondition(item.condition),\n          fulfill: {\n            state: item.state,\n          },\n          otherwise: {\n            state: item.otherwise,\n          },\n        })\n      }\n    }, [])\n  }\n  return []\n}\n\nconst SpecificationV1Polyfill = (schema: ISchema) => {\n  if (isValid(schema['editable'])) {\n    schema['x-editable'] = schema['x-editable'] || schema['editable']\n    delete schema['editable']\n  }\n  if (isValid(schema['visible'])) {\n    schema['x-visible'] = schema['x-visible'] || schema['visible']\n    delete schema['visible']\n  }\n  if (isValid(schema['display'])) {\n    schema['x-display'] =\n      schema['x-display'] || (schema['display'] ? 'visible' : 'hidden')\n    delete schema['display']\n  }\n  if (isValid(schema['x-props'])) {\n    schema['x-decorator-props'] =\n      schema['x-decorator-props'] || schema['x-props']\n    delete schema['display']\n  }\n  if (schema['x-linkages']) {\n    schema['x-reactions'] = toArr(schema['x-reactions']).concat(\n      transformXLinkage(schema['x-linkages'])\n    )\n    delete schema['x-linkages']\n  }\n  if (schema['x-component']) {\n    if (\n      VOID_COMPONENTS.some(\n        (component) => lowerCase(component) === lowerCase(schema['x-component'])\n      )\n    ) {\n      schema['type'] = 'void'\n    }\n  } else {\n    if (TYPE_DEFAULT_COMPONENTS[schema['type']]) {\n      schema['x-component'] = TYPE_DEFAULT_COMPONENTS[schema['type']]\n    }\n  }\n  if (\n    !schema['x-decorator'] &&\n    schema['type'] !== 'void' &&\n    schema['type'] !== 'object'\n  ) {\n    schema['x-decorator'] = schema['x-decorator'] || 'FormItem'\n  }\n  if (schema['x-rules']) {\n    schema['x-validator'] = []\n      .concat(schema['x-validator'] || [])\n      .concat(schema['x-rules'])\n  }\n  return schema\n}\n\nregisterPolyfills('1.0', SpecificationV1Polyfill)\n\nexport const registerVoidComponents = (components: string[]) => {\n  VOID_COMPONENTS.push(...components)\n}\n\nexport const registerTypeDefaultComponents = (maps: Record<string, string>) => {\n  Object.assign(TYPE_DEFAULT_COMPONENTS, maps)\n}\n", "export {};\n//# sourceMappingURL=types.js.map", "export { default as FormProvider } from './FormProvider'\nexport { default as FormConsumer } from './FormConsumer'\nexport { default as ArrayField } from './ArrayField'\nexport { default as ObjectField } from './ObjectField'\nexport { default as VoidField } from './VoidField'\nexport { default as RecursionField } from './RecursionField'\nexport { default as Field } from './Field'\nexport { createSchemaField } from './SchemaField'\nexport { ExpressionScope } from './ExpressionScope'\n", "import { provide, defineComponent, toRef } from 'vue-demi'\nimport {\n  FormSymbol,\n  FieldSymbol,\n  SchemaMarkupSymbol,\n  SchemaSymbol,\n  SchemaExpressionScopeSymbol,\n  SchemaOptionsSymbol,\n} from '../shared/context'\nimport { IProviderProps, DefineComponent } from '../types'\nimport { useAttach } from '../hooks/useAttach'\nimport { useInjectionCleaner } from '../hooks/useInjectionCleaner'\nimport h from '../shared/h'\nimport { Fragment } from '../shared/fragment'\n\nexport default defineComponent({\n  name: 'FormProvider',\n  inheritAttrs: false,\n  props: ['form'],\n  setup(props: IProviderProps, { slots }) {\n    const formRef = useAttach(toRef(props, 'form'))\n    provide(FormSymbol, formRef)\n    useInjectionCleaner([\n      FieldSymbol,\n      SchemaMarkupSymbol,\n      SchemaSymbol,\n      SchemaExpressionScopeSymbol,\n      SchemaOptionsSymbol,\n    ])\n\n    return () => h(Fragment, {}, slots)\n  },\n}) as DefineComponent<IProviderProps>\n", "import * as Vue from 'vue'\n\nvar isVue2 = false\nvar isVue3 = true\nvar Vue2 = undefined\n\nfunction install() {}\n\nexport function set(target, key, val) {\n  if (Array.isArray(target)) {\n    target.length = Math.max(target.length, key)\n    target.splice(key, 1, val)\n    return val\n  }\n  target[key] = val\n  return val\n}\n\nexport function del(target, key) {\n  if (Array.isArray(target)) {\n    target.splice(key, 1)\n    return\n  }\n  delete target[key]\n}\n\nexport * from 'vue'\nexport {\n  Vue,\n  Vue2,\n  isVue2,\n  isVue3,\n  install,\n}\n", "import { InjectionKey, Ref } from 'vue-demi'\nimport { Form, GeneralField } from '@formily/core'\nimport { Schema } from '@formily/json-schema'\nimport { ISchemaFieldVueFactoryOptions } from '../types'\nexport const FormSymbol: InjectionKey<Ref<Form>> = Symbol('form')\nexport const FieldSymbol: InjectionKey<Ref<GeneralField>> = Symbol('field')\nexport const SchemaMarkupSymbol: InjectionKey<Ref<Schema>> =\n  Symbol('schemaMarkup')\nexport const SchemaSymbol: InjectionKey<Ref<Schema>> = Symbol('schema')\nexport const SchemaExpressionScopeSymbol: InjectionKey<\n  Ref<Record<string, any>>\n> = Symbol('schemaExpression')\nexport const SchemaOptionsSymbol: InjectionKey<\n  Ref<ISchemaFieldVueFactoryOptions>\n> = Symbol('schemaOptions')\n", "import { onMounted, watch, Ref, onUnmounted, nextTick } from 'vue-demi'\n\ninterface IRecycleTarget {\n  onMount: () => void\n  onUnmount: () => void\n}\n\nexport const useAttach = <T extends IRecycleTarget>(target: Ref<T>): Ref<T> => {\n  watch(target, (v, old, onInvalidate) => {\n    if (v && v !== old) {\n      old?.onUnmount()\n      nextTick(() => v.onMount())\n      onInvalidate(() => v.onUnmount())\n    }\n  })\n  onMounted(() => {\n    target.value?.onMount()\n  })\n  onUnmounted(() => {\n    target.value?.onUnmount()\n  })\n  return target\n}\n", "import { InjectionKey, provide, Ref, ref } from 'vue-demi'\n\nexport const useInjectionCleaner = (\n  injectionKeys: InjectionKey<Ref<unknown>>[]\n) => {\n  injectionKeys.forEach((key) => provide(key, ref()))\n}\n", "var $placeholder = Symbol();\n\nvar $fakeParent = Symbol();\n\nvar nextSiblingPatched = Symbol();\n\nvar childNodesPatched = Symbol();\n\nvar isFrag = function isFrag(node) {\n    return \"frag\" in node;\n};\n\nfunction patchParentNode(node, fakeParent) {\n    if ($fakeParent in node) {\n        return;\n    }\n    node[$fakeParent] = fakeParent;\n    Object.defineProperty(node, \"parentNode\", {\n        get: function get() {\n            return this[$fakeParent] || this.parentElement;\n        }\n    });\n}\n\nfunction patchNextSibling(node) {\n    if (nextSiblingPatched in node) {\n        return;\n    }\n    node[nextSiblingPatched] = true;\n    Object.defineProperty(node, \"nextSibling\", {\n        get: function get() {\n            var childNodes = this.parentNode.childNodes;\n            var index = childNodes.indexOf(this);\n            if (index > -1) {\n                return childNodes[index + 1] || null;\n            }\n            return null;\n        }\n    });\n}\n\nfunction getTopFragment(node, fromParent) {\n    while (node.parentNode !== fromParent) {\n        var _node = node, parentNode = _node.parentNode;\n        if (parentNode) {\n            node = parentNode;\n        }\n    }\n    return node;\n}\n\nvar getChildNodes;\n\nfunction getChildNodesWithFragments(node) {\n    if (!getChildNodes) {\n        var childNodesDescriptor = Object.getOwnPropertyDescriptor(Node.prototype, \"childNodes\");\n        getChildNodes = childNodesDescriptor.get;\n    }\n    var realChildNodes = getChildNodes.apply(node);\n    var childNodes = Array.from(realChildNodes).map((function(childNode) {\n        return getTopFragment(childNode, node);\n    }));\n    return childNodes.filter((function(childNode, index) {\n        return childNode !== childNodes[index - 1];\n    }));\n}\n\nfunction patchChildNodes(node) {\n    if (childNodesPatched in node) {\n        return;\n    }\n    node[childNodesPatched] = true;\n    Object.defineProperties(node, {\n        childNodes: {\n            get: function get() {\n                return this.frag || getChildNodesWithFragments(this);\n            }\n        },\n        firstChild: {\n            get: function get() {\n                return this.childNodes[0] || null;\n            }\n        }\n    });\n    node.hasChildNodes = function() {\n        return this.childNodes.length > 0;\n    };\n}\n\nfunction before() {\n    var _this$frag$;\n    (_this$frag$ = this.frag[0]).before.apply(_this$frag$, arguments);\n}\n\nfunction remove() {\n    var frag = this.frag;\n    var removed = frag.splice(0, frag.length);\n    removed.forEach((function(node) {\n        node.remove();\n    }));\n}\n\nvar getFragmentLeafNodes = function getFragmentLeafNodes(children) {\n    var _Array$prototype;\n    return (_Array$prototype = Array.prototype).concat.apply(_Array$prototype, children.map((function(childNode) {\n        return isFrag(childNode) ? getFragmentLeafNodes(childNode.frag) : childNode;\n    })));\n};\n\nfunction addPlaceholder(node, insertBeforeNode) {\n    var placeholder = node[$placeholder];\n    insertBeforeNode.before(placeholder);\n    patchParentNode(placeholder, node);\n    node.frag.unshift(placeholder);\n}\n\nfunction removeChild(node) {\n    if (isFrag(this)) {\n        var hasChildInFragment = this.frag.indexOf(node);\n        if (hasChildInFragment > -1) {\n            var _this$frag$splice = this.frag.splice(hasChildInFragment, 1), removedNode = _this$frag$splice[0];\n            if (this.frag.length === 0) {\n                addPlaceholder(this, removedNode);\n            }\n            node.remove();\n        }\n    } else {\n        var children = getChildNodesWithFragments(this);\n        var hasChild = children.indexOf(node);\n        if (hasChild > -1) {\n            node.remove();\n        }\n    }\n    return node;\n}\n\nfunction insertBefore(insertNode, insertBeforeNode) {\n    var _this = this;\n    var insertNodes = insertNode.frag || [ insertNode ];\n    if (isFrag(this)) {\n        var _frag = this.frag;\n        if (insertBeforeNode) {\n            var index = _frag.indexOf(insertBeforeNode);\n            if (index > -1) {\n                _frag.splice.apply(_frag, [ index, 0 ].concat(insertNodes));\n                insertBeforeNode.before.apply(insertBeforeNode, insertNodes);\n            }\n        } else {\n            var _lastNode = _frag[_frag.length - 1];\n            _frag.push.apply(_frag, insertNodes);\n            _lastNode.after.apply(_lastNode, insertNodes);\n        }\n        removePlaceholder(this);\n    } else if (insertBeforeNode) {\n        if (this.childNodes.includes(insertBeforeNode)) {\n            insertBeforeNode.before.apply(insertBeforeNode, insertNodes);\n        }\n    } else {\n        this.append.apply(this, insertNodes);\n    }\n    insertNodes.forEach((function(node) {\n        patchParentNode(node, _this);\n    }));\n    var lastNode = insertNodes[insertNodes.length - 1];\n    patchNextSibling(lastNode);\n    return insertNode;\n}\n\nfunction appendChild(node) {\n    var frag = this.frag;\n    var lastChild = frag[frag.length - 1];\n    lastChild.after(node);\n    patchParentNode(node, this);\n    removePlaceholder(this);\n    frag.push(node);\n    return node;\n}\n\nfunction removePlaceholder(node) {\n    var placeholder = node[$placeholder];\n    if (node.frag[0] === placeholder) {\n        node.frag.shift();\n        placeholder.remove();\n    }\n}\n\nvar frag = {\n    inserted: function inserted(element) {\n        var parentNode = element.parentNode, nextSibling = element.nextSibling, previousSibling = element.previousSibling;\n        var childNodes = Array.from(element.childNodes);\n        var placeholder = document.createComment(\"\");\n        if (childNodes.length === 0) {\n            childNodes.push(placeholder);\n        }\n        element.frag = childNodes;\n        element[$placeholder] = placeholder;\n        var fragment = document.createDocumentFragment();\n        fragment.append.apply(fragment, getFragmentLeafNodes(childNodes));\n        element.replaceWith(fragment);\n        childNodes.forEach((function(node) {\n            patchParentNode(node, element);\n            patchNextSibling(node);\n        }));\n        patchChildNodes(element);\n        Object.assign(element, {\n            remove: remove,\n            appendChild: appendChild,\n            insertBefore: insertBefore,\n            removeChild: removeChild,\n            before: before\n        });\n        Object.defineProperty(element, \"innerHTML\", {\n            set: function set(htmlString) {\n                var _this2 = this;\n                var domify = document.createElement(\"div\");\n                domify.innerHTML = htmlString;\n                var oldNodesIndex = this.frag.length;\n                Array.from(domify.childNodes).forEach((function(node) {\n                    _this2.appendChild(node);\n                }));\n                domify.append.apply(domify, this.frag.splice(0, oldNodesIndex));\n            },\n            get: function get() {\n                return \"\";\n            }\n        });\n        if (parentNode) {\n            Object.assign(parentNode, {\n                removeChild: removeChild,\n                insertBefore: insertBefore\n            });\n            patchParentNode(element, parentNode);\n            patchChildNodes(parentNode);\n        }\n        if (nextSibling) {\n            patchNextSibling(element);\n        }\n        if (previousSibling) {\n            patchNextSibling(previousSibling);\n        }\n    },\n    unbind: function unbind(element) {\n        element.remove();\n    }\n};\n\nvar fragment = {\n    name: \"Fragment\",\n    directives: {\n        frag: frag\n    },\n    render: function render(h) {\n        return h(\"div\", {\n            directives: [ {\n                name: \"frag\"\n            } ]\n        }, this.$slots[\"default\"]);\n    }\n};\n\nexport { fragment as Fragment, frag as default };\n", "import { Fragment as FragmentV2 } from 'vue-frag'\nimport { DefineComponent } from '../types'\nimport { isVue2, defineComponent } from 'vue-demi'\n\nexport const Fragment = '#fragment'\n\nlet FragmentComponent: DefineComponent<{}>\n\nif (isVue2) {\n  FragmentComponent = {\n    name: 'Fragment',\n    ...FragmentV2,\n  } as unknown as DefineComponent<{}>\n} else {\n  /* istanbul ignore next */\n  FragmentComponent = defineComponent({\n    name: 'Fragment',\n    render() {\n      return this.$slots.default()\n    },\n  })\n}\n\nexport { FragmentComponent }\n", "import { each } from '@formily/shared'\n\ntype VNodeData = Record<string, any>\n\nexport const formatVue3VNodeData = (data: VNodeData) => {\n  const newData = {}\n  each(data, (value, key) => {\n    if (key === 'on' || key === 'nativeOn') {\n      if (value) {\n        each(value, (func, name) => {\n          const eventName = `on${\n            key === 'on' ? name[0].toUpperCase() : name[0]\n          }${name.slice(1)}`\n          newData[eventName] = func\n        })\n      }\n    } else if (key === 'attrs' || key === 'props' || key === 'domProps') {\n      Object.assign(newData, value)\n    } else {\n      newData[key] = value\n    }\n  })\n  return newData\n}\n", "import { h, isVue2 } from 'vue-demi'\nimport { Fragment, FragmentComponent } from './fragment'\nimport { formatVue3VNodeData } from '../utils/formatVNodeData'\n\ntype RenderChildren = {\n  [key in string]?: (...args: any[]) => (VNode | string)[]\n}\n\n// TODO: need to compatible with vue2 & vue3\ntype Tag = any\ntype VNodeData = Record<string, any>\ntype VNode = any\ntype VNodeChildren = any\n\nconst compatibleCreateElement = (\n  tag: Tag,\n  data: VNodeData,\n  components: RenderChildren\n): any => {\n  /* istanbul ignore else */\n  if (isVue2) {\n    const hInVue2 = h as (\n      tag: Tag,\n      data?: VNodeData,\n      components?: VNodeChildren\n    ) => VNode\n    const scopedSlots = components // \u9ED8\u8BA4\u5168\u90E8\u4F5C\u4E3A scopedSlots \u5904\u7406\n    const children = []\n\n    /**\n     * scopedSlots \u4E0D\u4F1A\u6620\u5C04\u4E3Aslots\uFF0C\u6240\u4EE5\u8FD9\u91CC\u624B\u52A8\u6620\u5C04\u4E00\u904D\n     * \u4E3B\u8981\u4E3A\u4E86\u89E3\u51B3 slots.x \u95EE\u9898\n     */\n    Object.keys(components).forEach((key) => {\n      const func = components[key]\n\n      // \u8F6C\u6362\u4E3A slots \u4F20\u9012\n      if (typeof func === 'function' && func.length === 0) {\n        /**\n         * func \u53C2\u6570\u4E3A0\u7684\u5224\u65AD\u4E0D\u51C6\u786E\uFF0C\u56E0\u4E3Acomposition-api\u5305\u4E86\u4E00\u5C42\uFF0C\u5BFC\u81F4\u5168\u90E8\u4E3A0\n         * try catch \u89E3\u51B3scoped slots \u8F6C\u6362\u53C2\u6570\u5F02\u5E38\u95EE\u9898\n         * */\n        try {\n          const child = func()\n          children.push(\n            key === 'default'\n              ? child\n              : hInVue2(FragmentComponent, { slot: key }, [child])\n          )\n        } catch (error) {}\n      }\n    })\n    const newData = Object.assign({}, data)\n    if (Object.keys(scopedSlots).length > 0) {\n      if (!newData.scopedSlots) {\n        newData.scopedSlots = scopedSlots\n      } else {\n        newData.scopedSlots = {\n          ...newData.scopedSlots,\n          ...scopedSlots,\n        }\n      }\n    }\n    if (tag === Fragment) {\n      // sometimes we needn't to use Fragment component.\n      if (children.length === 1) {\n        if (!Array.isArray(children[0])) {\n          return children[0]\n        } else if (children[0].length === 1) {\n          if (!Array.isArray(children[0][0])) {\n            return children[0][0]\n          } else if (children[0][0].length === 1) {\n            return children[0][0][0]\n          }\n        }\n      }\n      tag = FragmentComponent\n    }\n    return hInVue2(tag, newData, children)\n  } else {\n    if (tag === Fragment) {\n      tag = FragmentComponent\n    }\n    const hInVue3 = h as (\n      tag: Tag,\n      data?: VNodeData,\n      components?: RenderChildren\n    ) => VNode\n    return hInVue3(tag, formatVue3VNodeData(data), components)\n  }\n}\n\nexport default compatibleCreateElement\n\nexport { compatibleCreateElement as h }\n", "import { defineComponent } from 'vue-demi'\nimport { observer } from '@formily/reactive-vue'\nimport { useForm } from '../hooks'\nimport h from '../shared/h'\n\nexport default observer(\n  defineComponent({\n    name: 'FormConsumer',\n    inheritAttrs: false,\n    setup(props, { slots }) {\n      const formRef = useForm()\n      return () => {\n        // just like <Fragment>\n        return h(\n          'div',\n          { style: { display: 'contents' } },\n          {\n            default: () =>\n              slots.default?.({\n                form: formRef.value,\n              }),\n          }\n        )\n      }\n    },\n  }),\n  {\n    // make sure observables updated <cannot be tracked by tests>\n    scheduler: /* istanbul ignore next */ (update) =>\n      Promise.resolve().then(update),\n  }\n)\n", "export * from './useForm'\nexport * from './useField'\nexport * from './useFormEffects'\nexport * from './useFieldSchema'\nexport * from './useParentForm'\n", "import { inject, Ref, ref } from 'vue-demi'\nimport { Form } from '@formily/core'\nimport { FormSymbol } from '../shared/context'\n\nexport const useForm = (): Ref<Form> => {\n  const form = inject(FormSymbol, ref())\n  return form\n}\n", "import { inject, Ref, ref } from 'vue-demi'\nimport { GeneralField } from '@formily/core'\nimport { FieldSymbol } from '../shared/context'\n\nexport const useField = <T = GeneralField>(): Ref<T> => {\n  return inject(FieldSymbol, ref()) as any\n}\n", "import { onBeforeUnmount } from 'vue-demi'\nimport { Form } from '@formily/core'\nimport { uid } from '@formily/shared'\nimport { useForm } from './useForm'\n\nexport const useFormEffects = (effects?: (form: Form) => void): void => {\n  const formRef = useForm()\n\n  const id = uid()\n  formRef.value.addEffects(id, effects)\n\n  onBeforeUnmount(() => {\n    formRef.value.removeEffects(id)\n  })\n}\n", "import { inject, ref } from 'vue-demi'\nimport { SchemaSymbol } from '../shared/context'\n\nexport const useFieldSchema = () => {\n  return inject(SchemaSymbol, ref())\n}\n", "import { isObjectField, GeneralField, Form, ObjectField } from '@formily/core'\nimport { computed, Ref } from 'vue-demi'\nimport { useField } from './useField'\nimport { useForm } from './useForm'\n\nexport const useParentForm = (): Ref<Form | ObjectField> => {\n  const field = useField()\n  const form = useForm()\n  const findObjectParent = (field: GeneralField) => {\n    if (!field) return form.value\n    if (isObjectField(field)) return field\n    return findObjectParent(field?.parent)\n  }\n  return computed(() => findObjectParent(field.value))\n}\n", "export * from './context'\nexport * from './connect'\nexport * from './h'\nexport * from './fragment'\nexport * from './createForm'\n", "import { isVue2, markRaw, defineComponent, getCurrentInstance } from 'vue-demi'\nimport { isFn, isStr, FormPath, each } from '@formily/shared'\nimport { isVoidField, GeneralField } from '@formily/core'\nimport { observer } from '@formily/reactive-vue'\n\nimport { useField } from '../hooks/useField'\nimport h from './h'\n\nimport type {\n  VueComponent,\n  IComponentMapper,\n  IStateMapper,\n  VueComponentProps,\n} from '../types'\n\nexport function mapProps<T extends VueComponent = VueComponent>(\n  ...args: IStateMapper<VueComponentProps<T>>[]\n) {\n  const transform = (input: VueComponentProps<T>, field: GeneralField) =>\n    args.reduce((props, mapper) => {\n      if (isFn(mapper)) {\n        props = Object.assign(props, mapper(props, field))\n      } else {\n        each(mapper, (to, extract) => {\n          const extractValue = FormPath.getIn(field, extract)\n          const targetValue = isStr(to) ? to : extract\n          if (extract === 'value') {\n            if (to !== extract) {\n              delete props['value']\n            }\n          }\n          FormPath.setIn(props, targetValue, extractValue)\n        })\n      }\n      return props\n    }, input)\n\n  return (target: T) => {\n    /* istanbul ignore else */\n    if (isVue2) {\n      return defineComponent<VueComponentProps<T>>({\n        functional: true,\n        name: target.name ? `Connected${target.name}` : `ConnectedComponent`,\n        render(createElement, context) {\n          const fieldRef = useField()\n          const { data } = context\n          const attrs = fieldRef.value\n            ? transform(\n                { ...data.attrs, ...data.props } as VueComponentProps<T>,\n                fieldRef.value\n              )\n            : { ...data.attrs, ...data.props }\n          return createElement(target, { ...data, attrs }, context.children)\n        },\n      })\n    } else {\n      return observer(\n        defineComponent({\n          name: target.name ? `Connected${target.name}` : `ConnectedComponent`,\n          setup(props, { attrs, slots }) {\n            const fieldRef = useField()\n            return () => {\n              const newAttrs = fieldRef.value\n                ? transform(\n                    { ...attrs } as VueComponentProps<T>,\n                    fieldRef.value\n                  )\n                : { ...attrs }\n              return h(\n                target,\n                {\n                  attrs: newAttrs,\n                },\n                slots\n              )\n            }\n          },\n        })\n      )\n    }\n  }\n}\n\nexport function mapReadPretty<T extends VueComponent, C extends VueComponent>(\n  component: C,\n  readPrettyProps?: Record<string, any>\n) {\n  return (target: T) => {\n    return observer(\n      defineComponent({\n        name: target.name ? `Read${target.name}` : `ReadComponent`,\n        setup(props, { attrs, slots, listeners }: Record<string, any>) {\n          const fieldRef = useField()\n          return () => {\n            const field = fieldRef.value\n            return h(\n              field && !isVoidField(field) && field.pattern === 'readPretty'\n                ? component\n                : target,\n              {\n                attrs: {\n                  ...readPrettyProps,\n                  ...attrs,\n                },\n                on: listeners,\n              },\n              slots\n            )\n          }\n        },\n      })\n    )\n  }\n}\n\nexport function connect<T extends VueComponent>(\n  target: T,\n  ...args: IComponentMapper[]\n): T {\n  const Component = args.reduce((target: VueComponent, mapper) => {\n    return mapper(target)\n  }, target)\n  /* istanbul ignore else */\n  if (isVue2) {\n    const functionalComponent = defineComponent({\n      functional: true,\n      name: target.name,\n      render(h, context) {\n        return h(Component, context.data, context.children)\n      },\n    })\n    return markRaw(functionalComponent) as T\n  } else {\n    const functionalComponent = defineComponent({\n      name: target.name,\n      setup(props, { attrs, slots }) {\n        return () => {\n          return h(Component, { props, attrs }, slots)\n        }\n      },\n    })\n    return markRaw(functionalComponent) as T\n  }\n}\n", "import { createForm } from '@formily/core'\nimport { markRaw } from 'vue-demi'\n\nconst createRawForm = (...args: Parameters<typeof createForm>) => {\n  const form = createForm(...args)\n  return markRaw(form)\n}\n\nexport { createRawForm as createForm }\n", "import { inject, provide, Ref, ref, shallowRef, watch } from 'vue-demi'\nimport { GeneralField, isVoidField } from '@formily/core'\nimport { FormPath } from '@formily/shared'\nimport { observer } from '@formily/reactive-vue'\nimport { toJS } from '@formily/reactive'\nimport { SchemaOptionsSymbol, FieldSymbol, h, Fragment } from '../shared'\nimport { useAttach } from '../hooks/useAttach'\nimport { useField, useForm } from '../hooks'\n\nimport type {\n  IReactiveFieldProps,\n  VueComponentProps,\n  DefineComponent,\n} from '../types'\nimport type { VNode } from 'vue'\n\nfunction isVueOptions(options: Record<string, unknown>) {\n  return (\n    typeof options.template === 'string' ||\n    typeof options.render === 'function' ||\n    typeof options.setup === 'function'\n  )\n}\n\nconst wrapFragment = (childNodes: VNode[] | VNode): VNode => {\n  if (!Array.isArray(childNodes)) {\n    return childNodes\n  }\n  if (childNodes.length > 1) {\n    return h(Fragment, {}, { default: () => childNodes })\n  }\n  return childNodes[0]\n}\n\nconst resolveComponent = (render: () => unknown[], extra?: any) => {\n  if (extra === undefined || extra === null) {\n    return render\n  }\n  if (typeof extra === 'string') {\n    return () => [...render(), extra]\n  }\n  // not component\n  if (!isVueOptions(extra) && typeof extra !== 'function') {\n    return render\n  }\n  // for scoped slot\n  if (extra.length > 1 || extra?.render?.length > 1) {\n    return (scopedProps: VueComponentProps<any>) => [\n      ...render(),\n      h(extra, { props: scopedProps }, {}),\n    ]\n  }\n  return () => [...render(), h(extra, {}, {})]\n}\n\nconst mergeSlots = (\n  field: GeneralField,\n  slots: Record<string, any>,\n  content: any\n): Record<string, (...args: any) => any[]> => {\n  const slotNames = Object.keys(slots)\n  if (!slotNames.length) {\n    if (!content) {\n      return {}\n    }\n    if (typeof content === 'string') {\n      return {\n        default: resolveComponent(() => [], content),\n      }\n    }\n  }\n  const patchSlot = (slotName: string) => () =>\n    slots[slotName]?.({ field, form: field.form }) ?? []\n  const patchedSlots: Record<string, (...args: any) => unknown[]> = {}\n  slotNames.forEach((name) => {\n    patchedSlots[name] = patchSlot(name)\n  })\n\n  // for named slots\n  if (content && typeof content === 'object' && !isVueOptions(content)) {\n    Object.keys(content).forEach((key) => {\n      const child = content[key]\n      const slot = patchedSlots[key] ?? (() => [])\n      patchedSlots[key] = resolveComponent(slot, child)\n    })\n    return patchedSlots\n  }\n  // maybe default slot is empty\n  patchedSlots['default'] = resolveComponent(\n    patchedSlots['default'] ?? (() => []),\n    content\n  )\n  return patchedSlots\n}\n\nexport default observer({\n  name: 'ReactiveField',\n  props: {\n    fieldType: {\n      type: String,\n      default: 'Field',\n    },\n    fieldProps: {\n      type: Object,\n      default: () => ({}),\n    },\n  },\n  setup(props: IReactiveFieldProps, { slots }) {\n    const formRef = useForm()\n    const parentRef = useField()\n    const optionsRef = inject(SchemaOptionsSymbol, ref(null))\n    const createField = () =>\n      formRef?.value?.[`create${props.fieldType}`]?.({\n        ...props.fieldProps,\n        basePath: props.fieldProps?.basePath ?? parentRef.value?.address,\n      })\n    const fieldRef = shallowRef(createField()) as Ref<GeneralField>\n    watch(\n      () => props.fieldProps,\n      () => (fieldRef.value = createField())\n    )\n    useAttach(fieldRef)\n    provide(FieldSymbol, fieldRef)\n    return () => {\n      const field = fieldRef.value\n      const options = optionsRef.value\n      if (!field) {\n        return slots.default?.()\n      }\n      if (field.display !== 'visible') {\n        return h('template', {}, {})\n      }\n\n      const mergedSlots = mergeSlots(field, slots, field.content)\n\n      const renderDecorator = (childNodes: any[]) => {\n        if (!field.decoratorType) {\n          return wrapFragment(childNodes)\n        }\n        const finalComponent =\n          FormPath.getIn(options?.components, field.decoratorType as string) ??\n          field.decoratorType\n        const componentAttrs = toJS(field.decorator[1]) || {}\n        const componentData = {\n          attrs: componentAttrs,\n          style: componentAttrs?.style,\n          class: componentAttrs?.class,\n        }\n        delete componentData.attrs.style\n        delete componentData.attrs.class\n\n        return h(finalComponent, componentData, {\n          default: () => childNodes,\n        })\n      }\n\n      const renderComponent = () => {\n        if (!field.componentType) return wrapFragment(mergedSlots?.default?.())\n\n        const component =\n          FormPath.getIn(options?.components, field.componentType as string) ??\n          field.componentType\n\n        const originData = toJS(field.component[1]) || {}\n        const events = {} as Record<string, any>\n        const originChange = originData['@change'] || originData['onChange']\n        const originFocus = originData['@focus'] || originData['onFocus']\n        const originBlur = originData['@blur'] || originData['onBlur']\n\n        // '@xxx' has higher priority\n        Object.keys(originData)\n          .filter((key) => key.startsWith('on'))\n          .forEach((eventKey) => {\n            const eventName = `${eventKey[2].toLowerCase()}${eventKey.slice(3)}`\n            events[eventName] = originData[eventKey]\n          })\n\n        Object.keys(originData)\n          .filter((key) => key.startsWith('@'))\n          .forEach((eventKey) => {\n            events[eventKey.slice(1)] = originData[eventKey]\n            delete originData[eventKey]\n          })\n\n        events.change = (...args: any[]) => {\n          if (!isVoidField(field)) field.onInput(...args)\n          originChange?.(...args)\n        }\n        events.focus = (...args: any[]) => {\n          if (!isVoidField(field)) field.onFocus(...args)\n          originFocus?.(...args)\n        }\n        events.blur = (...args: any[]) => {\n          if (!isVoidField(field)) field.onBlur(...args)\n          originBlur?.(...args)\n        }\n\n        const componentData = {\n          attrs: {\n            disabled: !isVoidField(field)\n              ? field.pattern === 'disabled' || field.pattern === 'readPretty'\n              : undefined,\n            readOnly: !isVoidField(field)\n              ? field.pattern === 'readOnly'\n              : undefined,\n            ...originData,\n            value: !isVoidField(field) ? field.value : undefined,\n          },\n          style: originData?.style,\n          class: originData?.class,\n          on: events,\n        }\n        delete componentData.attrs.style\n        delete componentData.attrs.class\n\n        return h(component, componentData, mergedSlots)\n      }\n\n      return renderDecorator([renderComponent()])\n    }\n  },\n} as unknown as DefineComponent<IReactiveFieldProps>)\n", "import { IFieldProps, VueComponent } from '../types'\nimport { toRaw } from 'vue-demi'\n\nexport const getRawComponent = (\n  props: IFieldProps<VueComponent, VueComponent>\n) => {\n  const { component, decorator } = props\n  let newComponent: typeof props.component\n  let newDecorator: typeof props.component\n  if (Array.isArray(component)) {\n    newComponent = [toRaw(component[0]), component[1]]\n  }\n  if (Array.isArray(decorator)) {\n    newDecorator = [toRaw(decorator[0]), decorator[1]]\n  }\n  return { component: newComponent, decorator: newDecorator }\n}\n", "export const getFieldProps = () => ({\n  name: {},\n  title: {},\n  description: {},\n  value: {},\n  initialValue: {},\n  basePath: {},\n  decorator: Array,\n  component: Array,\n  display: String,\n  pattern: String,\n  required: { type: Boolean, default: undefined },\n  validateFirst: { type: Boolean, default: undefined },\n  hidden: { type: Boolean, default: undefined },\n  visible: { type: Boolean, default: undefined },\n  editable: { type: Boolean, default: undefined },\n  disabled: { type: Boolean, default: undefined },\n  readOnly: { type: Boolean, default: undefined },\n  readPretty: { type: Boolean, default: undefined },\n  dataSource: {},\n  validator: {},\n  reactions: [Array, Function],\n})\n\nexport const getVoidFieldProps = () => ({\n  name: {},\n  title: {},\n  description: {},\n  basePath: {},\n  decorator: Array,\n  component: Array,\n  display: String,\n  pattern: String,\n  hidden: { type: Boolean, default: undefined },\n  visible: { type: Boolean, default: undefined },\n  editable: { type: Boolean, default: undefined },\n  disabled: { type: Boolean, default: undefined },\n  readOnly: { type: Boolean, default: undefined },\n  readPretty: { type: Boolean, default: undefined },\n  reactions: [Array, Function],\n})\n", "import { isVue2, h as _h } from 'vue-demi'\nimport ReactiveField from './ReactiveField'\nimport { getRawComponent } from '../utils/getRawComponent'\n\nimport type { IArrayFieldProps, DefineComponent } from '../types'\nimport { getFieldProps } from '../utils/getFieldProps'\n\nlet ArrayField: DefineComponent<IArrayFieldProps>\n\n/* istanbul ignore else */\nif (isVue2) {\n  ArrayField = {\n    functional: true,\n    name: 'ArrayField',\n    props: getFieldProps(),\n    render(h, context) {\n      const props = context.props as IArrayFieldProps\n      const attrs = context.data.attrs\n      const componentData = {\n        ...context.data,\n        props: {\n          fieldType: 'ArrayField',\n          fieldProps: {\n            ...attrs,\n            ...props,\n            ...getRawComponent(props),\n          },\n        },\n      }\n      return _h(ReactiveField, componentData, context.children)\n    },\n  } as unknown as DefineComponent<IArrayFieldProps>\n} else {\n  ArrayField = {\n    name: 'ArrayField',\n    props: getFieldProps(),\n    setup(props: IArrayFieldProps, context) {\n      return () => {\n        const componentData = {\n          fieldType: 'ArrayField',\n          fieldProps: {\n            ...props,\n            ...getRawComponent(props),\n          },\n        } as Record<string, unknown>\n        return _h(ReactiveField, componentData, context.slots)\n      }\n    },\n  } as unknown as DefineComponent<IArrayFieldProps>\n}\n\nexport default ArrayField\n", "import { isVue2, h as _h } from 'vue-demi'\nimport ReactiveField from './ReactiveField'\nimport { getRawComponent } from '../utils/getRawComponent'\n\nimport type { IObjectFieldProps, DefineComponent } from '../types'\nimport { getFieldProps } from '../utils/getFieldProps'\n\nlet ObjectField: DefineComponent<IObjectFieldProps>\n\n/* istanbul ignore else */\nif (isVue2) {\n  ObjectField = {\n    functional: true,\n    name: 'ObjectField',\n    props: getFieldProps(),\n    render(h, context) {\n      const props = context.props as IObjectFieldProps\n      const attrs = context.data.attrs\n      const componentData = {\n        ...context.data,\n        props: {\n          fieldType: 'ObjectField',\n          fieldProps: {\n            ...attrs,\n            ...props,\n            ...getRawComponent(props),\n          },\n        },\n      }\n      return _h(ReactiveField, componentData, context.children)\n    },\n  } as unknown as DefineComponent<IObjectFieldProps>\n} else {\n  ObjectField = {\n    name: 'ObjectField',\n    props: getFieldProps(),\n    setup(props: IObjectFieldProps, context) {\n      return () => {\n        const componentData = {\n          fieldType: 'ObjectField',\n          fieldProps: {\n            ...props,\n            ...getRawComponent(props),\n          },\n        } as Record<string, unknown>\n        return _h(ReactiveField, componentData, context.slots)\n      }\n    },\n  } as unknown as DefineComponent<IObjectFieldProps>\n}\n\nexport default ObjectField\n", "import { isVue2, h as _h } from 'vue-demi'\nimport ReactiveField from './ReactiveField'\nimport { getRawComponent } from '../utils/getRawComponent'\n\nimport type { IVoidFieldProps, DefineComponent } from '../types'\nimport { getVoidFieldProps } from '../utils/getFieldProps'\n\nlet VoidField: DefineComponent<IVoidFieldProps>\n\n/* istanbul ignore else */\nif (isVue2) {\n  VoidField = {\n    functional: true,\n    name: 'VoidField',\n    props: getVoidFieldProps(),\n    render(h, context) {\n      const props = context.props as IVoidFieldProps\n      const attrs = context.data.attrs\n      const componentData = {\n        ...context.data,\n        props: {\n          fieldType: 'VoidField',\n          fieldProps: {\n            ...attrs,\n            ...props,\n            ...getRawComponent(props),\n          },\n        },\n      }\n      return _h(ReactiveField, componentData, context.children)\n    },\n  } as unknown as DefineComponent<IVoidFieldProps>\n} else {\n  VoidField = {\n    name: 'VoidField',\n    props: getVoidFieldProps(),\n    setup(props: IVoidFieldProps, context) {\n      return () => {\n        const componentData = {\n          fieldType: 'VoidField',\n          fieldProps: {\n            ...props,\n            ...getRawComponent(props),\n          },\n        } as Record<string, unknown>\n        return _h(ReactiveField, componentData, context.slots)\n      }\n    },\n  } as unknown as DefineComponent<IVoidFieldProps>\n}\n\nexport default VoidField\n", "import { isVue2, h as _h } from 'vue-demi'\nimport ReactiveField from './ReactiveField'\nimport { getRawComponent } from '../utils/getRawComponent'\n\nimport type { IFieldProps, DefineComponent } from '../types'\nimport { getFieldProps } from '../utils/getFieldProps'\n\nlet Field: DefineComponent<IFieldProps>\n\n/* istanbul ignore else */\nif (isVue2) {\n  Field = {\n    functional: true,\n    name: 'Field',\n    props: getFieldProps(),\n    render(h, context) {\n      const props = context.props as IFieldProps\n      const attrs = context.data.attrs\n      const componentData = {\n        ...context.data,\n        props: {\n          fieldType: 'Field',\n          fieldProps: {\n            ...attrs,\n            ...props,\n            ...getRawComponent(props),\n          },\n        },\n      }\n      return _h(ReactiveField, componentData, context.children)\n    },\n  } as unknown as DefineComponent<IFieldProps>\n} else {\n  Field = {\n    name: 'Field',\n    props: getFieldProps(),\n    setup(props: IFieldProps, context) {\n      return () => {\n        const componentData = {\n          fieldType: 'Field',\n          fieldProps: {\n            ...props,\n            ...getRawComponent(props),\n          },\n        } as Record<string, unknown>\n        return _h(ReactiveField, componentData, context.slots)\n      }\n    },\n  } as unknown as DefineComponent<IFieldProps>\n}\n\nexport default Field\n", "import { inject, provide, watch, shallowRef, computed, markRaw } from 'vue-demi'\nimport { GeneralField } from '@formily/core'\nimport { isFn, isValid } from '@formily/shared'\nimport { Schema } from '@formily/json-schema'\nimport {\n  SchemaSymbol,\n  SchemaOptionsSymbol,\n  SchemaExpressionScopeSymbol,\n} from '../shared'\nimport { useField } from '../hooks'\nimport ObjectField from './ObjectField'\nimport ArrayField from './ArrayField'\nimport Field from './Field'\nimport VoidField from './VoidField'\nimport { h } from '../shared/h'\nimport { Fragment } from '../shared/fragment'\n\nimport type { IRecursionFieldProps, DefineComponent } from '../types'\n\nconst resolveEmptySlot = (slots: Record<any, (...args: any[]) => any[]>) => {\n  return Object.keys(slots).length ? h(Fragment, {}, slots) : undefined\n}\n\nconst RecursionField = {\n  name: 'RecursionField',\n  inheritAttrs: false,\n  props: {\n    schema: {\n      required: true,\n    },\n    name: [String, Number],\n    basePath: {},\n    onlyRenderProperties: {\n      type: Boolean,\n      default: undefined,\n    },\n    onlyRenderSelf: {\n      type: Boolean,\n      default: undefined,\n    },\n    mapProperties: {},\n    filterProperties: {},\n  },\n  setup(props: IRecursionFieldProps) {\n    const parentRef = useField()\n    const optionsRef = inject(SchemaOptionsSymbol)\n    const scopeRef = inject(SchemaExpressionScopeSymbol)\n    const createSchema = (schemaProp: IRecursionFieldProps['schema']) =>\n      markRaw(new Schema(schemaProp))\n    const fieldSchemaRef = computed(() => createSchema(props.schema))\n\n    const getPropsFromSchema = (schema: Schema) =>\n      schema?.toFieldProps?.({\n        ...optionsRef.value,\n        get scope() {\n          return {\n            ...optionsRef.value.scope,\n            ...scopeRef.value,\n          }\n        },\n      })\n    const fieldPropsRef = shallowRef(getPropsFromSchema(fieldSchemaRef.value))\n\n    watch([fieldSchemaRef, optionsRef], () => {\n      fieldPropsRef.value = getPropsFromSchema(fieldSchemaRef.value)\n    })\n\n    const getBasePath = () => {\n      if (props.onlyRenderProperties) {\n        return props.basePath || parentRef?.value?.address.concat(props.name)\n      }\n      return props.basePath || parentRef?.value?.address\n    }\n\n    provide(SchemaSymbol, fieldSchemaRef)\n\n    return () => {\n      const basePath = getBasePath()\n      const fieldProps = fieldPropsRef.value\n\n      const generateSlotsByProperties = (scoped = false) => {\n        if (props.onlyRenderSelf) return {}\n        const properties = Schema.getOrderProperties(fieldSchemaRef.value)\n        if (!properties.length) return {}\n        const renderMap: Record<string, ((field?: GeneralField) => unknown)[]> =\n          {}\n        const setRender = (\n          key: string,\n          value: (field?: GeneralField) => unknown\n        ) => {\n          if (!renderMap[key]) {\n            renderMap[key] = []\n          }\n          renderMap[key].push(value)\n        }\n        properties.forEach(({ schema: item, key: name }, index) => {\n          let schema: Schema = item\n          if (isFn(props.mapProperties)) {\n            const mapped = props.mapProperties(item, name)\n            if (mapped) {\n              schema = mapped\n            }\n          }\n          if (isFn(props.filterProperties)) {\n            if (props.filterProperties(schema, name) === false) {\n              return null\n            }\n          }\n          setRender(schema['x-slot'] ?? 'default', (field?: GeneralField) =>\n            h(\n              RecursionField,\n              {\n                key: `${index}-${name}`,\n                attrs: {\n                  schema,\n                  name,\n                  basePath: field?.address || basePath,\n                },\n                slot: schema['x-slot'],\n              },\n              {}\n            )\n          )\n        })\n        const slots = {}\n        Object.keys(renderMap).forEach((key) => {\n          const renderFns = renderMap[key]\n          slots[key] = scoped\n            ? ({ field }) => renderFns.map((fn) => fn(field))\n            : () => renderFns.map((fn) => fn())\n        })\n        return slots\n      }\n\n      const render = () => {\n        if (!isValid(props.name))\n          return resolveEmptySlot(generateSlotsByProperties())\n        if (fieldSchemaRef.value.type === 'object') {\n          if (props.onlyRenderProperties)\n            return resolveEmptySlot(generateSlotsByProperties())\n          return h(\n            ObjectField,\n            {\n              attrs: {\n                ...fieldProps,\n                name: props.name,\n                basePath: basePath,\n              },\n            },\n            generateSlotsByProperties(true)\n          )\n        } else if (fieldSchemaRef.value.type === 'array') {\n          return h(\n            ArrayField,\n            {\n              attrs: {\n                ...fieldProps,\n                name: props.name,\n                basePath: basePath,\n              },\n            },\n            {}\n          )\n        } else if (fieldSchemaRef.value.type === 'void') {\n          if (props.onlyRenderProperties)\n            return resolveEmptySlot(generateSlotsByProperties())\n          const slots = generateSlotsByProperties(true)\n          return h(\n            VoidField,\n            {\n              attrs: {\n                ...fieldProps,\n                name: props.name,\n                basePath: basePath,\n              },\n            },\n            slots\n          )\n        }\n\n        return h(\n          Field,\n          {\n            attrs: {\n              ...fieldProps,\n              name: props.name,\n              basePath: basePath,\n            },\n          },\n          {}\n        )\n      }\n\n      if (!fieldSchemaRef.value) return\n\n      return render()\n    }\n  },\n} as unknown as DefineComponent<IRecursionFieldProps>\n\nexport default RecursionField\n", "import { paramCase } from '@formily/shared'\n\nexport const resolveSchemaProps = (props: Record<string, any>) => {\n  const newProps = {}\n  Object.keys(props).forEach((key) => {\n    if (key.indexOf('x') === 0 && key.indexOf('x-') === -1) {\n      newProps[paramCase(key)] = props[key]\n    } else {\n      newProps[key] = props[key]\n    }\n  })\n  return newProps\n}\n", "import { inject, provide, computed, shallowRef, watch } from 'vue-demi'\nimport { ISchema, Schema, SchemaTypes } from '@formily/json-schema'\nimport { RecursionField } from '../components'\nimport {\n  SchemaMarkupSymbol,\n  SchemaExpressionScopeSymbol,\n  SchemaOptionsSymbol,\n} from '../shared'\nimport {\n  ISchemaFieldVueFactoryOptions,\n  SchemaVueComponents,\n  ISchemaFieldProps,\n  ISchemaMarkupFieldProps,\n  ISchemaTypeFieldProps,\n} from '../types'\nimport { resolveSchemaProps } from '../utils/resolveSchemaProps'\nimport { h } from '../shared/h'\nimport { Fragment } from '../shared/fragment'\nimport type { DefineComponent } from '../types'\n\ntype SchemaFieldComponents = {\n  SchemaField: DefineComponent<ISchemaFieldProps>\n  SchemaMarkupField: DefineComponent<ISchemaMarkupFieldProps>\n  SchemaStringField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaObjectField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaArrayField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaBooleanField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaDateField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaDateTimeField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaVoidField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaNumberField: DefineComponent<ISchemaTypeFieldProps>\n}\n\nconst env = {\n  nonameId: 0,\n}\n\nconst getRandomName = () => {\n  return `NO_NAME_FIELD_$${env.nonameId++}`\n}\n\nconst markupProps = {\n  version: String,\n  name: [String, Number],\n  title: {},\n  description: {},\n  default: {},\n  readOnly: {\n    type: Boolean,\n    default: undefined,\n  },\n  writeOnly: {\n    type: Boolean,\n    default: undefined,\n  },\n  enum: {},\n  const: {},\n  multipleOf: Number,\n  maximum: Number,\n  exclusiveMaximum: Number,\n  minimum: Number,\n  exclusiveMinimum: Number,\n  maxLength: Number,\n  minLength: Number,\n  pattern: {},\n  maxItems: Number,\n  minItems: Number,\n  uniqueItems: {\n    type: Boolean,\n    default: undefined,\n  },\n  maxProperties: Number,\n  minProperties: Number,\n  required: {\n    type: [Boolean, Array, String],\n    default: undefined,\n  },\n  format: String,\n  properties: {},\n  items: {},\n  additionalItems: {},\n  patternProperties: {},\n  additionalProperties: {},\n  xIndex: Number,\n  xPattern: {},\n  xDisplay: {},\n  xValidator: {},\n  xDecorator: {},\n  xDecoratorProps: {},\n  xComponent: {},\n  xComponentProps: {},\n  xReactions: {},\n  xContent: {},\n  xVisible: {\n    type: Boolean,\n    default: undefined,\n  },\n  xHidden: {\n    type: Boolean,\n    default: undefined,\n  },\n  xDisabled: {\n    type: Boolean,\n    default: undefined,\n  },\n  xEditable: {\n    type: Boolean,\n    default: undefined,\n  },\n  xReadOnly: {\n    type: Boolean,\n    default: undefined,\n  },\n  xReadPretty: {\n    type: Boolean,\n    default: undefined,\n  },\n}\n\nexport function createSchemaField<\n  Components extends SchemaVueComponents = SchemaVueComponents\n>(options: ISchemaFieldVueFactoryOptions<Components>): SchemaFieldComponents {\n  const SchemaField = {\n    name: 'SchemaField',\n    inheritAttrs: false,\n    props: {\n      schema: {},\n      scope: {},\n      components: {},\n      name: [String, Number],\n      basePath: {},\n      onlyRenderProperties: { type: Boolean, default: undefined },\n      onlyRenderSelf: { type: Boolean, default: undefined },\n      mapProperties: {},\n      filterProperties: {},\n    },\n    setup(props: ISchemaFieldProps, { slots }) {\n      const schemaRef = computed(() =>\n        Schema.isSchemaInstance(props.schema)\n          ? props.schema\n          : new Schema({\n              type: 'object',\n              ...props.schema,\n            })\n      )\n\n      const scopeRef = computed(() => ({\n        ...options.scope,\n        ...props.scope,\n      }))\n\n      const optionsRef = computed(() => ({\n        ...options,\n        components: {\n          ...options.components,\n          ...props.components,\n        },\n      }))\n\n      provide(SchemaMarkupSymbol, schemaRef)\n      provide(SchemaOptionsSymbol, optionsRef)\n      provide(SchemaExpressionScopeSymbol, scopeRef)\n\n      return () => {\n        env.nonameId = 0\n\n        return h(\n          Fragment,\n          {},\n          {\n            default: () => {\n              const children = []\n              if (slots.default) {\n                children.push(\n                  h(\n                    'template',\n                    {},\n                    {\n                      default: () => slots.default(),\n                    }\n                  )\n                )\n              }\n              children.push(\n                h(\n                  RecursionField,\n                  {\n                    attrs: {\n                      ...props,\n                      schema: schemaRef.value,\n                    },\n                  },\n                  {}\n                )\n              )\n              return children\n            },\n          }\n        )\n      }\n    },\n  }\n\n  const MarkupField = {\n    name: 'MarkupField',\n    props: {\n      type: String,\n      ...markupProps,\n    },\n    setup(props: ISchemaMarkupFieldProps, { slots }) {\n      const parentRef = inject(SchemaMarkupSymbol, null)\n      if (!parentRef || !parentRef.value) return () => h('template', {}, {})\n\n      const name = props.name || getRandomName()\n      const appendArraySchema = (schema: ISchema) => {\n        if (parentRef.value.items) {\n          return parentRef.value.addProperty(name, schema)\n        } else {\n          return parentRef.value.setItems(resolveSchemaProps(props))\n        }\n      }\n\n      const schemaRef = shallowRef(null)\n\n      watch(\n        parentRef,\n        () => {\n          if (\n            parentRef.value.type === 'object' ||\n            parentRef.value.type === 'void'\n          ) {\n            schemaRef.value = parentRef.value.addProperty(\n              name,\n              resolveSchemaProps(props)\n            )\n          } else if (parentRef.value.type === 'array') {\n            const schema = appendArraySchema(resolveSchemaProps(props))\n            schemaRef.value = Array.isArray(schema) ? schema[0] : schema\n          }\n        },\n        { immediate: true }\n      )\n      provide(SchemaMarkupSymbol, schemaRef)\n\n      return () => {\n        return h('div', { style: 'display: none;' }, slots)\n      }\n    },\n  }\n\n  const SchemaFieldFactory = (type: SchemaTypes, name: string) => {\n    return {\n      name: name,\n      props: { ...markupProps },\n      setup(props: ISchemaTypeFieldProps, { slots }) {\n        return () =>\n          h(\n            MarkupField,\n            {\n              attrs: {\n                ...props,\n                type: type,\n              },\n            },\n            slots\n          )\n      },\n    }\n  }\n\n  return {\n    SchemaField,\n    SchemaMarkupField: MarkupField,\n    SchemaStringField: SchemaFieldFactory('string', 'SchemaStringField'),\n    SchemaObjectField: SchemaFieldFactory('object', 'SchemaObjectField'),\n    SchemaArrayField: SchemaFieldFactory('array', 'SchemaArrayField'),\n    SchemaBooleanField: SchemaFieldFactory('boolean', 'SchemaBooleanField'),\n    SchemaDateField: SchemaFieldFactory('date', 'SchemaDateField'),\n    SchemaDateTimeField: SchemaFieldFactory('datetime', 'SchemaDatetimeField'),\n    SchemaVoidField: SchemaFieldFactory('void', 'SchemaVoidField'),\n    SchemaNumberField: SchemaFieldFactory('number', 'SchemaNumberField'),\n  } as unknown as SchemaFieldComponents\n}\n", "import { computed, defineComponent, inject, provide, Ref } from 'vue-demi'\nimport { SchemaExpressionScopeSymbol, Fragment, h } from '../shared'\nimport { IExpressionScopeProps } from '../types'\n\nexport const ExpressionScope = defineComponent({\n  name: 'ExpressionScope',\n  props: ['value'],\n  setup(props: IExpressionScopeProps, { slots }) {\n    const scopeRef = inject<Ref>(SchemaExpressionScopeSymbol)\n    const expressionScopeRef = computed(() => ({\n      ...scopeRef.value,\n      ...props.value,\n    }))\n\n    provide(SchemaExpressionScopeSymbol, expressionScopeRef)\n\n    return () => h(Fragment, {}, slots)\n  },\n})\n", "import { Component } from 'vue'\nimport * as VueDemi from 'vue-demi'\nimport {\n  Form,\n  IFieldFactoryProps,\n  IVoidFieldFactoryProps,\n  GeneralField,\n  Field,\n  ObjectField,\n  FormPatternTypes,\n  FieldDisplayTypes,\n  FieldValidator,\n} from '@formily/core'\nimport type { FormPathPattern } from '@formily/shared'\nimport type { ISchema, Schema, SchemaKey } from '@formily/json-schema'\n\nclass Helper<Props> {\n  Return = VueDemi.defineComponent({} as { props: Record<keyof Props, any> })\n}\n\nexport type DefineComponent<Props> = Helper<Props>['Return']\n\nexport type VueComponent = Component\n\nexport type VueComponentOptionsWithProps = {\n  props: unknown\n}\n\nexport type VueComponentProps<T extends VueComponent> =\n  T extends VueComponentOptionsWithProps ? T['props'] : T\n\nexport interface IProviderProps {\n  form: Form\n}\n\nexport type IFieldProps<\n  D extends VueComponent = VueComponent,\n  C extends VueComponent = VueComponent\n> = IFieldFactoryProps<D, C>\n\nexport type IVoidFieldProps<\n  D extends VueComponent = VueComponent,\n  C extends VueComponent = VueComponent\n> = IVoidFieldFactoryProps<D, C>\n\nexport type IArrayFieldProps = IFieldProps\nexport type IObjectFieldProps = IFieldProps\n\nexport interface IReactiveFieldProps {\n  fieldType: 'Field' | 'ArrayField' | 'ObjectField' | 'VoidField'\n  fieldProps: IFieldProps | IVoidFieldProps\n}\n\nexport interface IComponentMapper<T extends VueComponent = any> {\n  (target: T): VueComponent\n}\n\nexport type IStateMapper<Props> =\n  | {\n      [key in keyof Field]?: keyof Props | boolean\n    }\n  | ((props: Props, field: GeneralField) => Props)\n\nexport type SchemaVueComponents = Record<string, VueComponent>\n\nexport interface ISchemaFieldVueFactoryOptions<\n  Components extends SchemaVueComponents = any\n> {\n  components?: Components\n  scope?: any\n}\n\nexport interface ISchemaFieldProps\n  extends Omit<IRecursionFieldProps, 'name' | 'schema'> {\n  schema?: ISchema\n  components?: {\n    [key: string]: VueComponent\n  }\n  scope?: any\n  name?: SchemaKey\n}\n\nexport interface ISchemaMapper {\n  (schema: Schema, name: SchemaKey): Schema\n}\n\nexport interface ISchemaFilter {\n  (schema: Schema, name: SchemaKey): boolean\n}\n\nexport interface IRecursionFieldProps {\n  schema: Schema\n  name?: SchemaKey\n  basePath?: FormPathPattern\n  onlyRenderProperties?: boolean\n  onlyRenderSelf?: boolean\n  mapProperties?: ISchemaMapper\n  filterProperties?: ISchemaFilter\n}\n\nexport type ObjectKey = string | number | boolean | symbol\n\nexport type KeyOfComponents<T> = keyof T\n\nexport type ComponentPath<\n  T,\n  Key extends KeyOfComponents<T> = KeyOfComponents<T>\n> = Key extends string ? Key : never\n\nexport type ComponentPropsByPathValue<\n  T extends SchemaVueComponents,\n  P extends ComponentPath<T>\n> = P extends keyof T ? VueComponentProps<T[P]> : never\n\nexport type ISchemaMarkupFieldProps<\n  Components extends SchemaVueComponents = SchemaVueComponents,\n  Decorator extends ComponentPath<Components> = ComponentPath<Components>,\n  Component extends ComponentPath<Components> = ComponentPath<Components>\n> = ISchema<\n  Decorator,\n  Component,\n  ComponentPropsByPathValue<Components, Decorator>,\n  ComponentPropsByPathValue<Components, Component>,\n  FormPatternTypes,\n  FieldDisplayTypes,\n  FieldValidator,\n  string,\n  GeneralField\n>\n\nexport type ISchemaTypeFieldProps<\n  Components extends SchemaVueComponents = SchemaVueComponents,\n  Decorator extends ComponentPath<Components> = ComponentPath<Components>,\n  Component extends ComponentPath<Components> = ComponentPath<Components>\n> = Omit<ISchemaMarkupFieldProps<Components, Decorator, Component>, 'type'>\n\nexport type IExpressionScopeProps = {\n  value: any\n}\n", "// This file just converts types\nimport * as components from './components'\n\nimport type Vue from 'vue'\nimport type { VueConstructor } from 'vue'\nimport type {\n  IVoidFieldProps,\n  IArrayFieldProps,\n  IObjectFieldProps,\n  IFieldProps,\n  IRecursionFieldProps,\n  IProviderProps,\n  ISchemaMarkupFieldProps,\n  ISchemaFieldProps,\n  ISchemaFieldVueFactoryOptions,\n  ISchemaTypeFieldProps,\n  SchemaVueComponents,\n} from './types'\n\nconst {\n  Field: _Field,\n  ArrayField: _ArrayField,\n  FormConsumer: _FormConsumer,\n  FormProvider: _FormProvider,\n  ObjectField: _ObjectField,\n  RecursionField: _RecursionField,\n  VoidField: _VoidField,\n  createSchemaField: _createSchemaField,\n} = components\n\ntype DefineComponent<Props> = Vue & VueConstructor & Props\n\ntype SchemaFieldComponents = {\n  SchemaField: DefineComponent<Omit<ISchemaFieldProps, 'name' | 'components'>>\n  SchemaMarkupField: DefineComponent<ISchemaMarkupFieldProps>\n  SchemaStringField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaObjectField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaArrayField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaBooleanField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaDateField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaDateTimeField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaVoidField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaNumberField: DefineComponent<ISchemaTypeFieldProps>\n}\n\ntype CreateSchemaField<\n  Components extends SchemaVueComponents = SchemaVueComponents\n> = (\n  options: ISchemaFieldVueFactoryOptions<Components>\n) => SchemaFieldComponents\n\nconst Field = _Field as unknown as DefineComponent<Omit<IFieldProps, 'name'>>\nconst ArrayField = _ArrayField as unknown as DefineComponent<\n  Omit<IArrayFieldProps, 'name'>\n>\nconst ObjectField = _ObjectField as unknown as DefineComponent<\n  Omit<IObjectFieldProps, 'name'>\n>\nconst VoidField = _VoidField as unknown as DefineComponent<\n  Omit<IVoidFieldProps, 'name'>\n>\nconst RecursionField = _RecursionField as unknown as DefineComponent<\n  Omit<IRecursionFieldProps, 'name'>\n>\nconst FormConsumer = _FormConsumer as unknown as DefineComponent<{}>\nconst FormProvider = _FormProvider as unknown as DefineComponent<IProviderProps>\nconst createSchemaField = _createSchemaField as unknown as CreateSchemaField\n\nexport {\n  Field,\n  ArrayField,\n  ObjectField,\n  VoidField,\n  RecursionField,\n  FormConsumer,\n  FormProvider,\n  createSchemaField,\n}\n"],
  "mappings": "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",
  "names": []
}
